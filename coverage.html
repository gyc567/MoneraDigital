
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>account: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">monera-digital/internal/account/account_client.go (55.7%)</option>
				
				<option value="file1">monera-digital/internal/binance/price.go (0.0%)</option>
				
				<option value="file2">monera-digital/internal/cache/cache_keys.go (0.0%)</option>
				
				<option value="file3">monera-digital/internal/cache/cache_service.go (0.0%)</option>
				
				<option value="file4">monera-digital/internal/cache/redis_cache.go (0.0%)</option>
				
				<option value="file5">monera-digital/internal/cache/token_blacklist.go (0.0%)</option>
				
				<option value="file6">monera-digital/internal/config/config.go (0.0%)</option>
				
				<option value="file7">monera-digital/internal/config/twofa.go (0.0%)</option>
				
				<option value="file8">monera-digital/internal/container/container.go (10.0%)</option>
				
				<option value="file9">monera-digital/internal/coreapi/wallet_client.go (59.5%)</option>
				
				<option value="file10">monera-digital/internal/currency/currency.go (84.0%)</option>
				
				<option value="file11">monera-digital/internal/db/db.go (0.0%)</option>
				
				<option value="file12">monera-digital/internal/docs/swagger.go (0.0%)</option>
				
				<option value="file13">monera-digital/internal/handlers/account_handler.go (0.0%)</option>
				
				<option value="file14">monera-digital/internal/handlers/base.go (100.0%)</option>
				
				<option value="file15">monera-digital/internal/handlers/core/core_account.go (0.0%)</option>
				
				<option value="file16">monera-digital/internal/handlers/deposit_handler.go (0.0%)</option>
				
				<option value="file17">monera-digital/internal/handlers/handlers.go (14.8%)</option>
				
				<option value="file18">monera-digital/internal/handlers/twofa_handler.go (34.9%)</option>
				
				<option value="file19">monera-digital/internal/handlers/wallet_handler.go (44.6%)</option>
				
				<option value="file20">monera-digital/internal/logger/logger.go (0.0%)</option>
				
				<option value="file21">monera-digital/internal/middleware/auth.go (0.0%)</option>
				
				<option value="file22">monera-digital/internal/middleware/error_handler.go (0.0%)</option>
				
				<option value="file23">monera-digital/internal/middleware/middleware.go (0.0%)</option>
				
				<option value="file24">monera-digital/internal/middleware/rate_limit.go (0.0%)</option>
				
				<option value="file25">monera-digital/internal/migration/migrations/001_create_users_table.go (0.0%)</option>
				
				<option value="file26">monera-digital/internal/migration/migrations/002_create_lending_positions_table.go (0.0%)</option>
				
				<option value="file27">monera-digital/internal/migration/migrations/003_create_withdrawal_tables.go (0.0%)</option>
				
				<option value="file28">monera-digital/internal/migration/migrations/004_add_two_factor_columns.go (9.1%)</option>
				
				<option value="file29">monera-digital/internal/migration/migrations/005_add_two_factor_timestamp.go (12.5%)</option>
				
				<option value="file30">monera-digital/internal/migration/migrations/007_update_wallet_requests_table.go (0.0%)</option>
				
				<option value="file31">monera-digital/internal/migration/migrations/008_create_user_wallets_table.go (0.0%)</option>
				
				<option value="file32">monera-digital/internal/migration/migrations/009_user_wallet_status.go (0.0%)</option>
				
				<option value="file33">monera-digital/internal/migration/migrator.go (0.0%)</option>
				
				<option value="file34">monera-digital/internal/models/token.go (0.0%)</option>
				
				<option value="file35">monera-digital/internal/monitoring/health_check.go (0.0%)</option>
				
				<option value="file36">monera-digital/internal/monitoring/metrics.go (0.0%)</option>
				
				<option value="file37">monera-digital/internal/monitoring/monitoring_middleware.go (0.0%)</option>
				
				<option value="file38">monera-digital/internal/performance/benchmark.go (0.0%)</option>
				
				<option value="file39">monera-digital/internal/repository/postgres/account.go (18.9%)</option>
				
				<option value="file40">monera-digital/internal/repository/postgres/address.go (0.0%)</option>
				
				<option value="file41">monera-digital/internal/repository/postgres/deposit.go (0.0%)</option>
				
				<option value="file42">monera-digital/internal/repository/postgres/user.go (0.0%)</option>
				
				<option value="file43">monera-digital/internal/repository/postgres/wallet.go (0.0%)</option>
				
				<option value="file44">monera-digital/internal/repository/postgres/wealth.go (0.0%)</option>
				
				<option value="file45">monera-digital/internal/repository/postgres/withdrawal.go (11.8%)</option>
				
				<option value="file46">monera-digital/internal/routes/routes.go (0.0%)</option>
				
				<option value="file47">monera-digital/internal/scheduler/interest.go (64.3%)</option>
				
				<option value="file48">monera-digital/internal/scheduler/metrics.go (97.5%)</option>
				
				<option value="file49">monera-digital/internal/scheduler/timezone.go (81.8%)</option>
				
				<option value="file50">monera-digital/internal/services/address.go (0.0%)</option>
				
				<option value="file51">monera-digital/internal/services/auth.go (65.5%)</option>
				
				<option value="file52">monera-digital/internal/services/auth_refresh.go (0.0%)</option>
				
				<option value="file53">monera-digital/internal/services/deposit.go (66.7%)</option>
				
				<option value="file54">monera-digital/internal/services/encryption_service.go (86.7%)</option>
				
				<option value="file55">monera-digital/internal/services/lending.go (37.8%)</option>
				
				<option value="file56">monera-digital/internal/services/safeheron_service.go (0.0%)</option>
				
				<option value="file57">monera-digital/internal/services/twofa_service.go (0.0%)</option>
				
				<option value="file58">monera-digital/internal/services/wallet.go (48.2%)</option>
				
				<option value="file59">monera-digital/internal/services/wealth.go (68.2%)</option>
				
				<option value="file60">monera-digital/internal/services/withdrawal_service.go (53.5%)</option>
				
				<option value="file61">monera-digital/internal/utils/crypto.go (0.0%)</option>
				
				<option value="file62">monera-digital/internal/utils/jwt.go (0.0%)</option>
				
				<option value="file63">monera-digital/internal/validator/validator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package account

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "time"

        "monera-digital/internal/dto"
        "monera-digital/internal/logger"
        "net/url"

        "go.uber.org/zap"
)

// APIError represents an error from the account system API.
type APIError struct {
        StatusCode int
        Message    string
}

func (e *APIError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("API error: status_code=%d, message=%s", e.StatusCode, e.Message)
}</span>

// Client is a client for the account system API.
type Client struct {
        baseURL    string
        httpClient *http.Client
        logger     *zap.SugaredLogger
}

// NewClient creates a new account system API client.
func NewClient(baseURL string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                logger: logger.GetLogger().With("service", "AccountClient"),
        }
}</span>

// GetUserAccounts retrieves all accounts for a given user.
func (c *Client) GetUserAccounts(ctx context.Context, req dto.GetUserAccountsRequest) (*dto.GetUserAccountsResponse, error) <span class="cov8" title="1">{
        httpReq, err := http.NewRequestWithContext(ctx, "GET", fmt.Sprintf("%s/accounts?userId=%s", c.baseURL, req.UserID), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var resp dto.GetUserAccountsResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// CreateAccount creates a new account for a user.
func (c *Client) CreateAccount(ctx context.Context, req dto.CreateAccountRequest) (*dto.CreateAccountResponse, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/accounts", c.baseURL), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var resp dto.CreateAccountResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// GetAccountHistory retrieves the transaction history for an account.
func (c *Client) GetAccountHistory(ctx context.Context, req dto.GetAccountHistoryRequest) (*dto.GetAccountHistoryResponse, error) <span class="cov0" title="0">{
        u, err := url.Parse(fmt.Sprintf("%s/accounts/history", c.baseURL))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">q := u.Query()
        q.Set("accountId", req.AccountID)
        q.Set("userId", req.UserID)
        q.Set("currency", req.Currency)
        q.Set("startTime", req.StartTime)
        q.Set("endTime", req.EndTime)
        q.Set("page", fmt.Sprintf("%d", req.Page))
        q.Set("size", fmt.Sprintf("%d", req.Size))
        u.RawQuery = q.Encode()

        httpReq, err := http.NewRequestWithContext(ctx, "GET", u.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var resp dto.GetAccountHistoryResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;resp, nil</span>
}

// FreezeBalance freezes a specified amount in an account.
func (c *Client) FreezeBalance(ctx context.Context, req dto.FreezeBalanceRequest) (*dto.FreezeBalanceResponse, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/accounts/freeze", c.baseURL), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var resp dto.FreezeBalanceResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// UnfreezeBalance unfreezes a specified amount in an account.
func (c *Client) UnfreezeBalance(ctx context.Context, req dto.UnfreezeBalanceRequest) (*dto.UnfreezeBalanceResponse, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/accounts/unfreeze", c.baseURL), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var resp dto.UnfreezeBalanceResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// Transfer moves funds between two accounts.
func (c *Client) Transfer(ctx context.Context, req dto.TransferRequest) (*dto.TransferResponse, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">httpReq, err := http.NewRequestWithContext(ctx, "POST", fmt.Sprintf("%s/accounts/transfer", c.baseURL), bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var resp dto.TransferResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;resp, nil</span>
}

func (c *Client) doRequest(req *http.Request, v interface{}) error <span class="cov8" title="1">{
        req.Header.Set("Content-Type", "application/json")
        // TODO: Add authentication headers

        l := c.logger.With("method", req.Method, "url", req.URL.String())
        l.Debug("sending API request")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                l.Errorw("API request failed", "error", err)
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                l.Errorw("failed to read response body", "error", err)
                return err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                l.Warnw("API request returned non-200 status", "status_code", resp.StatusCode, "body", string(body))
                return &amp;APIError{
                        StatusCode: resp.StatusCode,
                        Message:    string(body),
                }
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, v); err != nil </span><span class="cov0" title="0">{
                l.Errorw("failed to decode response", "error", err, "body", string(body))
                return fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov8" title="1">l.Debug("API request successful")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package binance

import (
        "encoding/json"
        "fmt"
        "io"
        "log"
        "net/http"
        "strings"
        "sync"
        "time"
)

type PriceResponse struct {
        Symbol string `json:"symbol"`
        Price  string `json:"price"`
}

type PriceCache struct {
        Prices    map[string]float64
        UpdatedAt time.Time
}

type PriceService struct {
        baseURL    string
        httpClient *http.Client
        cache      *PriceCache
        cacheMu    sync.RWMutex
        ticker     *time.Ticker
        stopChan   chan struct{}
}

var (
        instance *PriceService
        once     sync.Once
)

func NewPriceService() *PriceService <span class="cov0" title="0">{
        once.Do(func() </span><span class="cov0" title="0">{
                instance = &amp;PriceService{
                        baseURL: "https://api.binance.com",
                        httpClient: &amp;http.Client{
                                Timeout: 10 * time.Second,
                        },
                        cache: &amp;PriceCache{
                                Prices:    make(map[string]float64),
                                UpdatedAt: time.Now(),
                        },
                        stopChan: make(chan struct{}),
                }

                go instance.startBackgroundFetcher()
        }</span>)
        <span class="cov0" title="0">return instance</span>
}

func (s *PriceService) startBackgroundFetcher() <span class="cov0" title="0">{
        fetchInterval := 5 * time.Minute
        s.ticker = time.NewTicker(fetchInterval)

        s.fetchAllPrices()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ticker.C:<span class="cov0" title="0">
                        s.fetchAllPrices()</span>
                case &lt;-s.stopChan:<span class="cov0" title="0">
                        log.Println("[PriceService] Background fetcher stopped")
                        return</span>
                }
        }
}

func (s *PriceService) Stop() <span class="cov0" title="0">{
        if s.ticker != nil </span><span class="cov0" title="0">{
                s.ticker.Stop()
        }</span>
        <span class="cov0" title="0">close(s.stopChan)</span>
}

func (s *PriceService) fetchAllPrices() <span class="cov0" title="0">{
        symbols := []string{"BTC", "ETH", "SOL", "ADA", "XRP", "DOGE"}

        symbolStrings := make([]string, len(symbols))
        for i, sym := range symbols </span><span class="cov0" title="0">{
                symbolStrings[i] = "\"" + sym + "USDT\""
        }</span>
        <span class="cov0" title="0">url := s.baseURL + "/api/v3/ticker/price?symbols=[" + strings.Join(symbolStrings, ",") + "]"

        resp, err := s.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[PriceService] Failed to fetch prices: %v", err)
                return
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                log.Printf("[PriceService] HTTP error: %d", resp.StatusCode)
                body, _ := io.ReadAll(resp.Body)
                log.Printf("[PriceService] Response body: %s", string(body))
                return
        }</span>

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("[PriceService] Failed to read response: %v", err)
                return
        }</span>

        <span class="cov0" title="0">var priceList []PriceResponse
        if err := json.Unmarshal(body, &amp;priceList); err != nil </span><span class="cov0" title="0">{
                log.Printf("[PriceService] Failed to parse JSON: %v", err)
                return
        }</span>

        <span class="cov0" title="0">s.cacheMu.Lock()
        for _, price := range priceList </span><span class="cov0" title="0">{
                symbol := strings.TrimSuffix(price.Symbol, "USDT")
                s.cache.Prices[symbol] = parsePriceSilent(price.Price)
        }</span>
        <span class="cov0" title="0">s.cache.Prices["USDT"] = 1.0
        s.cache.Prices["USDC"] = 1.0
        s.cache.Prices["DAI"] = 1.0
        s.cache.UpdatedAt = time.Now()
        s.cacheMu.Unlock()

        log.Printf("[PriceService] Prices updated successfully at %s", s.cache.UpdatedAt.Format("2006-01-02 15:04:05"))</span>
}

func (s *PriceService) GetCachedPrice(currency string) (float64, bool) <span class="cov0" title="0">{
        s.cacheMu.RLock()
        price, ok := s.cache.Prices[currency]
        s.cacheMu.RUnlock()
        return price, ok
}</span>

func (s *PriceService) GetCachedPrices() map[string]float64 <span class="cov0" title="0">{
        s.cacheMu.RLock()
        defer s.cacheMu.RUnlock()

        result := make(map[string]float64)
        for k, v := range s.cache.Prices </span><span class="cov0" title="0">{
                result[k] = v
        }</span>
        <span class="cov0" title="0">return result</span>
}

func (s *PriceService) GetLastUpdateTime() time.Time <span class="cov0" title="0">{
        s.cacheMu.RLock()
        defer s.cacheMu.RUnlock()
        return s.cache.UpdatedAt
}</span>

func (s *PriceService) FetchAllPricesForAPI() <span class="cov0" title="0">{
        s.fetchAllPrices()
}</span>

func (s *PriceService) GetUSDValueFromCache(amount float64, currency string) float64 <span class="cov0" title="0">{
        if currency == "USDT" || currency == "USDC" || currency == "DAI" </span><span class="cov0" title="0">{
                return amount
        }</span>

        <span class="cov0" title="0">price, ok := s.GetCachedPrice(currency)
        if !ok </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return amount * price</span>
}

func (s *PriceService) GetPricesFromCache(currencies []string) map[string]float64 <span class="cov0" title="0">{
        prices := make(map[string]float64)
        for _, currency := range currencies </span><span class="cov0" title="0">{
                price, ok := s.GetCachedPrice(currency)
                if ok </span><span class="cov0" title="0">{
                        prices[currency] = price
                }</span>
        }
        <span class="cov0" title="0">return prices</span>
}

func (s *PriceService) GetSinglePrice(currency string) (float64, error) <span class="cov0" title="0">{
        url := s.baseURL + "/api/v3/ticker/price?symbol=" + currency + "USDT"
        resp, err := s.httpClient.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var price PriceResponse
        if err := json.Unmarshal(body, &amp;price); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return parsePrice(price.Price)</span>
}

func (s *PriceService) RefreshPrice(currency string) error <span class="cov0" title="0">{
        price, err := s.GetSinglePrice(currency)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.cacheMu.Lock()
        s.cache.Prices[currency] = price
        s.cache.UpdatedAt = time.Now()
        s.cacheMu.Unlock()

        return nil</span>
}

func parsePrice(priceStr string) (float64, error) <span class="cov0" title="0">{
        var price float64
        _, err := fmt.Sscanf(priceStr, "%f", &amp;price)
        return price, err
}</span>

func parsePriceSilent(priceStr string) float64 <span class="cov0" title="0">{
        price, _ := parsePrice(priceStr)
        return price
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// internal/cache/cache_keys.go
package cache

import "fmt"

// Cache key constants and builders for consistent key naming

const (
        // User cache keys
        UserKeyPrefix = "user:"
        UserEmailKey  = "user:email:"

        // Lending cache keys
        LendingKeyPrefix     = "lending:"
        LendingPositionKey   = "lending:position:"
        LendingUserPositions = "lending:user_positions:"

        // Address cache keys
        AddressKeyPrefix = "address:"
        UserAddresses    = "address:user:"

        // Withdrawal cache keys
        WithdrawalKeyPrefix = "withdrawal:"
        UserWithdrawals     = "withdrawal:user:"

        // Rate limit cache keys
        RateLimitKeyPrefix = "ratelimit:"

        // Session cache keys
        SessionKeyPrefix = "session:"

        // Token blacklist cache keys
        TokenBlacklistPrefix = "token:blacklist:"
)

// User cache key builders
func UserCacheKey(userID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", UserKeyPrefix, userID)
}</span>

func UserEmailCacheKey(email string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", UserEmailKey, email)
}</span>

// Lending cache key builders
func LendingPositionCacheKey(positionID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", LendingPositionKey, positionID)
}</span>

func UserLendingPositionsCacheKey(userID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", LendingUserPositions, userID)
}</span>

// Address cache key builders
func UserAddressesCacheKey(userID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", UserAddresses, userID)
}</span>

func AddressCacheKey(addressID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", AddressKeyPrefix, addressID)
}</span>

// Withdrawal cache key builders
func UserWithdrawalsCacheKey(userID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", UserWithdrawals, userID)
}</span>

func WithdrawalCacheKey(withdrawalID int) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%d", WithdrawalKeyPrefix, withdrawalID)
}</span>

// Rate limit cache key builder
func RateLimitCacheKey(identifier string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", RateLimitKeyPrefix, identifier)
}</span>

// Session cache key builder
func SessionCacheKey(sessionID string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", SessionKeyPrefix, sessionID)
}</span>

// Token blacklist cache key builder
func TokenBlacklistCacheKey(token string) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s%s", TokenBlacklistPrefix, token)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// internal/cache/cache_service.go
package cache

import (
        "context"
        "time"
)

// CacheService defines the interface for caching operations
type CacheService interface {
        // Get retrieves a value from cache
        Get(ctx context.Context, key string) (string, error)

        // Set stores a value in cache with TTL
        Set(ctx context.Context, key string, value string, ttl time.Duration) error

        // Delete removes a value from cache
        Delete(ctx context.Context, key string) error

        // Exists checks if a key exists in cache
        Exists(ctx context.Context, key string) (bool, error)

        // Increment increments a numeric value
        Increment(ctx context.Context, key string) (int64, error)

        // Decrement decrements a numeric value
        Decrement(ctx context.Context, key string) (int64, error)

        // SetWithExpiry sets a value with absolute expiry time
        SetWithExpiry(ctx context.Context, key string, value string, expiry time.Time) error

        // GetTTL gets remaining TTL for a key
        GetTTL(ctx context.Context, key string) (time.Duration, error)

        // FlushAll clears all cache entries
        FlushAll(ctx context.Context) error

        // Close closes the cache connection
        Close() error
}

// CacheError represents a cache operation error
type CacheError struct {
        Operation string
        Key       string
        Message   string
}

func (e *CacheError) Error() string <span class="cov0" title="0">{
        return "cache error: " + e.Message + " (operation: " + e.Operation + ", key: " + e.Key + ")"
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// internal/cache/redis_cache.go
package cache

import (
        "context"
        "fmt"
        "time"

        "github.com/redis/go-redis/v9"
)

// RedisCache implements CacheService using Redis
type RedisCache struct {
        client *redis.Client
}

// NewRedisCache creates a new Redis cache instance
func NewRedisCache(addr string, password string, db int) (*RedisCache, error) <span class="cov0" title="0">{
        client := redis.NewClient(&amp;redis.Options{
                Addr:     addr,
                Password: password,
                DB:       db,
        })

        // Test connection
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := client.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                return nil, &amp;CacheError{
                        Operation: "connect",
                        Key:       "",
                        Message:   fmt.Sprintf("failed to connect to Redis: %v", err),
                }
        }</span>

        <span class="cov0" title="0">return &amp;RedisCache{client: client}, nil</span>
}

// Get retrieves a value from cache
func (rc *RedisCache) Get(ctx context.Context, key string) (string, error) <span class="cov0" title="0">{
        val, err := rc.client.Get(ctx, key).Result()
        if err == redis.Nil </span><span class="cov0" title="0">{
                return "", nil // Key doesn't exist
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", &amp;CacheError{
                        Operation: "get",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Set stores a value in cache with TTL
func (rc *RedisCache) Set(ctx context.Context, key string, value string, ttl time.Duration) error <span class="cov0" title="0">{
        err := rc.client.Set(ctx, key, value, ttl).Err()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CacheError{
                        Operation: "set",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Delete removes a value from cache
func (rc *RedisCache) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        err := rc.client.Del(ctx, key).Err()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CacheError{
                        Operation: "delete",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Exists checks if a key exists in cache
func (rc *RedisCache) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        exists, err := rc.client.Exists(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return false, &amp;CacheError{
                        Operation: "exists",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return exists &gt; 0, nil</span>
}

// Increment increments a numeric value
func (rc *RedisCache) Increment(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        val, err := rc.client.Incr(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, &amp;CacheError{
                        Operation: "increment",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// Decrement decrements a numeric value
func (rc *RedisCache) Decrement(ctx context.Context, key string) (int64, error) <span class="cov0" title="0">{
        val, err := rc.client.Decr(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, &amp;CacheError{
                        Operation: "decrement",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return val, nil</span>
}

// SetWithExpiry sets a value with absolute expiry time
func (rc *RedisCache) SetWithExpiry(ctx context.Context, key string, value string, expiry time.Time) error <span class="cov0" title="0">{
        ttl := time.Until(expiry)
        if ttl &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;CacheError{
                        Operation: "set_with_expiry",
                        Key:       key,
                        Message:   "expiry time is in the past",
                }
        }</span>
        <span class="cov0" title="0">return rc.Set(ctx, key, value, ttl)</span>
}

// GetTTL gets remaining TTL for a key
func (rc *RedisCache) GetTTL(ctx context.Context, key string) (time.Duration, error) <span class="cov0" title="0">{
        ttl, err := rc.client.TTL(ctx, key).Result()
        if err != nil </span><span class="cov0" title="0">{
                return 0, &amp;CacheError{
                        Operation: "get_ttl",
                        Key:       key,
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return ttl, nil</span>
}

// FlushAll clears all cache entries
func (rc *RedisCache) FlushAll(ctx context.Context) error <span class="cov0" title="0">{
        err := rc.client.FlushAll(ctx).Err()
        if err != nil </span><span class="cov0" title="0">{
                return &amp;CacheError{
                        Operation: "flush_all",
                        Key:       "",
                        Message:   err.Error(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Close closes the Redis connection
func (rc *RedisCache) Close() error <span class="cov0" title="0">{
        return rc.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// internal/cache/token_blacklist.go
package cache

import (
        "context"
        "sync"
        "time"
)

// TokenBlacklist 令牌黑名单
type TokenBlacklist struct {
        tokens map[string]time.Time
        mu     sync.RWMutex
        ticker *time.Ticker
        done   chan bool
        ctx    context.Context
        cancel context.CancelFunc
}

// NewTokenBlacklist 创建令牌黑名单
func NewTokenBlacklist() *TokenBlacklist <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        tb := &amp;TokenBlacklist{
                tokens: make(map[string]time.Time),
                ticker: time.NewTicker(1 * time.Hour),
                done:   make(chan bool, 1),
                ctx:    ctx,
                cancel: cancel,
        }

        // 启动清理过期令牌的后台任务
        go tb.cleanupExpiredTokens()

        return tb
}</span>

// Add 添加令牌到黑名单
func (tb *TokenBlacklist) Add(token string, expiry time.Time) <span class="cov0" title="0">{
        tb.mu.Lock()
        defer tb.mu.Unlock()
        tb.tokens[token] = expiry
}</span>

// IsBlacklisted 检查令牌是否在黑名单中
func (tb *TokenBlacklist) IsBlacklisted(token string) bool <span class="cov0" title="0">{
        tb.mu.RLock()
        defer tb.mu.RUnlock()

        expiry, exists := tb.tokens[token]
        if !exists </span><span class="cov0" title="0">{
                return false
        }</span>

        // 检查令牌是否已过期
        <span class="cov0" title="0">if time.Now().After(expiry) </span><span class="cov0" title="0">{
                // 令牌已过期，不需要在黑名单中
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// cleanupExpiredTokens 清理过期的令牌
func (tb *TokenBlacklist) cleanupExpiredTokens() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-tb.ticker.C:<span class="cov0" title="0">
                        tb.mu.Lock()
                        now := time.Now()
                        for token, expiry := range tb.tokens </span><span class="cov0" title="0">{
                                if now.After(expiry) </span><span class="cov0" title="0">{
                                        delete(tb.tokens, token)
                                }</span>
                        }
                        <span class="cov0" title="0">tb.mu.Unlock()</span>

                case &lt;-tb.ctx.Done():<span class="cov0" title="0">
                        tb.ticker.Stop()
                        return</span>
                }
        }
}

// Close 关闭黑名单
func (tb *TokenBlacklist) Close() <span class="cov0" title="0">{
        tb.cancel()
}</span>

// Size 获取黑名单中的令牌数量
func (tb *TokenBlacklist) Size() int <span class="cov0" title="0">{
        tb.mu.RLock()
        defer tb.mu.RUnlock()
        return len(tb.tokens)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package config

import (
        "github.com/spf13/viper"
)

type Config struct {
        Port          string
        DatabaseURL   string
        RedisURL      string
        JWTSecret     string
        EncryptionKey string
}

func Load() *Config <span class="cov0" title="0">{
        viper.SetConfigFile(".env")
        viper.ReadInConfig() // Ignore error if .env doesn't exist

        // Use PORT from environment, default to 80 for Cloud Run compatibility
        viper.SetDefault("PORT", "80")
        viper.SetDefault("DATABASE_URL", "postgres://user:password@localhost/monera?sslmode=disable")
        viper.SetDefault("REDIS_URL", "redis://localhost:6379")
        viper.SetDefault("JWT_SECRET", "your-secret-key")

        viper.AutomaticEnv()

        cfg := &amp;Config{
                Port:          viper.GetString("PORT"),
                DatabaseURL:   viper.GetString("DATABASE_URL"),
                RedisURL:      viper.GetString("REDIS_URL"),
                JWTSecret:     viper.GetString("JWT_SECRET"),
                EncryptionKey: viper.GetString("ENCRYPTION_KEY"),
        }

        return cfg
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package config

import (
        "os"
        "strconv"

        "github.com/pquerna/otp"
)

// TwoFactorConfig holds 2FA configuration
type TwoFactorConfig struct {
        Issuer          string        // TOTP issuer name
        Period          uint          // TOTP period in seconds (default: 30)
        Digits          int           // Number of digits in TOTP code (default: 6)
        SecretSize      int           // Secret key size in bytes (default: 20 = 160 bits)
        Algorithm       otp.Algorithm // HMAC algorithm (default: SHA1)
        Skew            uint          // Time window for validation (default: 1 = ±30s)
        BackupCodeCount int           // Number of backup codes to generate (default: 10)
}

// LoadTwoFactorConfig loads 2FA configuration from environment variables
func LoadTwoFactorConfig() *TwoFactorConfig <span class="cov0" title="0">{
        return &amp;TwoFactorConfig{
                Issuer:          getEnvOrDefault("TWOFA_ISSUER", "Monera Digital"),
                Period:          getEnvUintOrDefault("TWOFA_PERIOD", 30),
                Digits:          getEnvIntOrDefault("TWOFA_DIGITS", 6),
                SecretSize:      getEnvIntOrDefault("TWOFA_SECRET_SIZE", 20), // 160 bits
                Algorithm:       otp.AlgorithmSHA1,                            // Google Authenticator standard
                Skew:            getEnvUintOrDefault("TWOFA_SKEW", 1),         // ±30 seconds
                BackupCodeCount: getEnvIntOrDefault("TWOFA_BACKUP_COUNT", 10),
        }
}</span>

// Helper functions
func getEnvOrDefault(key, defaultValue string) string <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvIntOrDefault(key string, defaultValue int) int <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil </span><span class="cov0" title="0">{
                        return intVal
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}

func getEnvUintOrDefault(key string, defaultValue uint) uint <span class="cov0" title="0">{
        if value := os.Getenv(key); value != "" </span><span class="cov0" title="0">{
                if intVal, err := strconv.Atoi(value); err == nil &amp;&amp; intVal &gt;= 0 </span><span class="cov0" title="0">{
                        return uint(intVal)
                }</span>
        }
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// internal/container/container.go
package container

import (
        "database/sql"
        "log"
        "os"

        "monera-digital/internal/cache"
        "monera-digital/internal/coreapi"
        "monera-digital/internal/middleware"
        "monera-digital/internal/repository"
        "monera-digital/internal/repository/postgres"
        "monera-digital/internal/services"
)

// ContainerOption 配置选项函数
type ContainerOption func(*Container)

// WithEncryption 配置加密服务和 2FA 服务
func WithEncryption(key string) ContainerOption <span class="cov8" title="1">{
        return func(c *Container) </span><span class="cov8" title="1">{
                // Normalize encryption key (support hex-encoded or raw format)
                normalizedKey, err := services.DecodeEncryptionKey(key)
                if err != nil </span><span class="cov8" title="1">{
                        log.Printf("Warning: Invalid encryption key format: %v", err)
                        return
                }</span>

                <span class="cov0" title="0">encryptionService, err := services.NewEncryptionService(normalizedKey)
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Warning: Failed to initialize encryption service: %v", err)
                        return
                }</span>
                <span class="cov0" title="0">c.EncryptionService = encryptionService
                c.TwoFAService = services.NewTwoFactorService(c.DB, encryptionService)</span>
        }
}

// Container 依赖注入容器
type Container struct {
        // 基础设施
        DB *sql.DB

        // 配置
        JWTSecret string

        // 缓存
        TokenBlacklist *cache.TokenBlacklist
        RateLimiter    *middleware.RateLimiter

        // 外部 API 客户端
        CoreAPIClient *coreapi.Client

        // 仓储
        Repository *repository.Repository

        // 服务
        AuthService       *services.AuthService
        LendingService    *services.LendingService
        AddressService    *services.AddressService
        WithdrawalService *services.WithdrawalService
        DepositService    *services.DepositService
        WalletService     *services.WalletService
        WealthService     *services.WealthService
        EncryptionService *services.EncryptionService
        TwoFAService      *services.TwoFactorService

        // 中间件
        RateLimitMiddleware *middleware.PerEndpointRateLimiter
}

// NewContainer 创建依赖注入容器
func NewContainer(db *sql.DB, jwtSecret string, opts ...ContainerOption) *Container <span class="cov0" title="0">{
        c := &amp;Container{DB: db, JWTSecret: jwtSecret}

        // 初始化缓存
        c.TokenBlacklist = cache.NewTokenBlacklist()
        c.RateLimiter = middleware.NewRateLimiter(5, 60)

        // 初始化 Core API 客户端
        coreAPIURL := os.Getenv("MONNAIRE_CORE_API_URL")
        if coreAPIURL == "" </span><span class="cov0" title="0">{
                coreAPIURL = "http://198.13.57.142:8080" // 默认测试环境
        }</span>
        <span class="cov0" title="0">c.CoreAPIClient = coreapi.NewClient(coreAPIURL)

        // 初始化仓储
        c.Repository = &amp;repository.Repository{
                User:       postgres.NewUserRepository(db),
                Deposit:    postgres.NewDepositRepository(db),
                Wallet:     postgres.NewWalletRepository(db),
                Account:    postgres.NewAccountRepositoryV1(db), // Legacy interface
                AccountV2:  postgres.NewAccountRepository(db),   // New detailed interface
                Address:    postgres.NewAddressRepository(db),
                Withdrawal: postgres.NewWithdrawalRepository(db),
        }

        // 初始化核心服务
        c.AuthService = services.NewAuthService(db, jwtSecret)
        c.AuthService.SetTokenBlacklist(c.TokenBlacklist)

        c.LendingService = services.NewLendingService(db)
        c.AddressService = services.NewAddressService(c.Repository.Address)
        c.WithdrawalService = services.NewWithdrawalService(db, c.Repository, services.NewSafeheronService())
        c.DepositService = services.NewDepositService(c.Repository.Deposit)
        c.WalletService = services.NewWalletService(c.Repository.Wallet, c.CoreAPIClient)
        c.WealthService = services.NewWealthService(c.Repository.Wealth, c.Repository.AccountV2, c.Repository.Journal)

        // 应用配置选项 (按顺序执行)
        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>

        // 注入TwoFactorService依赖（如果在选项函数中已初始化）
        <span class="cov0" title="0">if c.TwoFAService != nil </span><span class="cov0" title="0">{
                c.AuthService.SetTwoFactorService(c.TwoFAService)
        }</span>

        // 初始化中间件
        <span class="cov0" title="0">c.RateLimitMiddleware = middleware.NewPerEndpointRateLimiter()
        c.RateLimitMiddleware.AddEndpoint("/api/auth/register", 5, 60)
        c.RateLimitMiddleware.AddEndpoint("/api/auth/login", 5, 60)
        c.RateLimitMiddleware.AddEndpoint("/api/auth/refresh", 10, 60)

        return c</span>
}

// Close 关闭容器中的资源
func (c *Container) Close() error <span class="cov0" title="0">{
        if c.TokenBlacklist != nil </span><span class="cov0" title="0">{
                c.TokenBlacklist.Close()
        }</span>
        <span class="cov0" title="0">if c.DB != nil </span><span class="cov0" title="0">{
                return c.DB.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Verify 验证容器中的所有依赖
func (c *Container) Verify() error <span class="cov0" title="0">{
        // 验证数据库连接
        if err := c.DB.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Printf("Database connection failed: %v", err)
                return err
        }</span>

        // 验证核心服务初始化
        <span class="cov0" title="0">services := []struct {
                name  string
                value interface{}
        }{
                {"AuthService", c.AuthService},
                {"LendingService", c.LendingService},
                {"AddressService", c.AddressService},
                {"WithdrawalService", c.WithdrawalService},
                {"DepositService", c.DepositService},
                {"WalletService", c.WalletService},
        }

        for _, s := range services </span><span class="cov0" title="0">{
                if s.value == nil </span><span class="cov0" title="0">{
                        log.Printf("%s not initialized", s.name)
                }</span>
        }

        <span class="cov0" title="0">log.Println("Container verification passed")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package coreapi

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "time"
)

// Client is a client for the Core API (Monnaire Core System).
type Client struct {
        baseURL    string
        httpClient *http.Client
}

// CoreAPIResponse represents the response from Core API.
type CoreAPIResponse struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data"`
        Message string      `json:"message"`
        Code    string      `json:"code"`
}

// NewClient creates a new Core API client.
func NewClient(baseURL string) *Client <span class="cov8" title="1">{
        return &amp;Client{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
        }
}</span>

// CreateWalletRequest represents the request to create a wallet.
type CreateWalletRequest struct {
        UserID      int    `json:"userId"`
        ProductCode string `json:"productCode"`
        Currency    string `json:"currency"`
}

// CreateWalletResponse represents the response from wallet creation.
type CreateWalletResponse struct {
        WalletID  string            `json:"walletId"`
        Address   string            `json:"address"`
        Addresses map[string]string `json:"addresses"`
        Status    string            `json:"status"`
        CreatedAt time.Time         `json:"createdAt"`
}

// CreateWallet calls the Core API to create a wallet.
func (c *Client) CreateWallet(ctx context.Context, req CreateWalletRequest) (*CreateWalletResponse, error) <span class="cov0" title="0">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov0" title="0">url := fmt.Sprintf("%s/api/v1/wallet/create", c.baseURL)
        httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")

        var resp CoreAPIResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !resp.Success </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet creation failed: %s", resp.Message)
        }</span>

        <span class="cov0" title="0">respData, err := json.Marshal(resp.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal response data: %w", err)
        }</span>

        <span class="cov0" title="0">var walletResp CreateWalletResponse
        if err := json.Unmarshal(respData, &amp;walletResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;walletResp, nil</span>
}

// GetIncomeHistoryRequest 请求结构
type GetIncomeHistoryRequest struct {
        Address string `json:"address"`
}

// GetAddressRequest 请求结构
type GetAddressRequest struct {
        UserID      int    `json:"userId"`
        ProductCode string `json:"productCode"`
        Currency    string `json:"currency"`
}

// AddressInfo 钱包地址信息
type AddressInfo struct {
        Address     string  `json:"address"`
        AddressType *string `json:"addressType"`
        DerivePath  *string `json:"derivePath"`
}

// AddressIncomeRecord 收款记录结构
type AddressIncomeRecord struct {
        TxKey             string `json:"txKey"`
        TxHash            string `json:"txHash"`
        CoinKey           string `json:"coinKey"`
        TxAmount          string `json:"txAmount"`
        Address           string `json:"address"`
        TransactionStatus string `json:"transactionStatus"`
        BlockHeight       int64  `json:"blockHeight"`
        CreateTime        string `json:"createTime"`
        CompletedTime     string `json:"completedTime"`
}

// GetAddress 获取钱包地址
func (c *Client) GetAddress(ctx context.Context, req GetAddressRequest) (*AddressInfo, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">url := fmt.Sprintf("%s/api/v1/wallet/address/get", c.baseURL)
        httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">httpReq.Header.Set("Content-Type", "application/json")

        var resp CoreAPIResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.Success </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("get address failed: %s", resp.Message)
        }</span>

        <span class="cov8" title="1">respData, err := json.Marshal(resp.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal response data: %w", err)
        }</span>

        <span class="cov8" title="1">var addressInfo AddressInfo
        if err := json.Unmarshal(respData, &amp;addressInfo); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;addressInfo, nil</span>
}

// GetIncomeHistory 获取地址链上收款记录
func (c *Client) GetIncomeHistory(ctx context.Context, req GetIncomeHistoryRequest) ([]AddressIncomeRecord, error) <span class="cov8" title="1">{
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">url := fmt.Sprintf("%s/api/v1/wallet/address/incomeHistory", c.baseURL)
        httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov8" title="1">httpReq.Header.Set("Content-Type", "application/json")

        var resp CoreAPIResponse
        if err := c.doRequest(httpReq, &amp;resp); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !resp.Success </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("income history query failed: %s", resp.Message)
        }</span>

        <span class="cov8" title="1">respData, err := json.Marshal(resp.Data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal response data: %w", err)
        }</span>

        <span class="cov8" title="1">var incomeRecords []AddressIncomeRecord
        if err := json.Unmarshal(respData, &amp;incomeRecords); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov8" title="1">return incomeRecords, nil</span>
}

func (c *Client) doRequest(req *http.Request, v interface{}) error <span class="cov8" title="1">{
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        body, err := ioutil.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read response body: %w", err)
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return fmt.Errorf("API error: status=%d, body=%s", resp.StatusCode, string(body))
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(body, v); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CoreAPIClientInterface defines the interface for Core API client operations.
// This allows for easier testing with mocks.
type CoreAPIClientInterface interface {
        CreateWallet(ctx context.Context, req CreateWalletRequest) (*CreateWalletResponse, error)
        GetAddress(ctx context.Context, req GetAddressRequest) (*AddressInfo, error)
        GetIncomeHistory(ctx context.Context, req GetIncomeHistoryRequest) ([]AddressIncomeRecord, error)
}

var _ CoreAPIClientInterface = (*Client)(nil)
</pre>
		
		<pre class="file" id="file10" style="display: none">package currency

import "strings"

// Supported currencies following token_network format
const (
        USDT_ERC20 = "USDT_ERC20"
        USDT_TRC20 = "USDT_TRC20"
        USDT_BEP20 = "USDT_BEP20"
        USDC_ERC20 = "USDC_ERC20"
        USDC_TRC20 = "USDC_TRC20"
        USDC_BEP20 = "USDC_BEP20"
)

// SupportedNetworks contains all valid network identifiers
var SupportedNetworks = []string{
        "ERC20",
        "TRC20",
        "BEP20",
}

// NetworkAliasMap maps common aliases to standard network names
var NetworkAliasMap = map[string]string{
        "TRON": "TRC20",
        "BSC":  "BEP20",
        "ETH":  "ERC20",
}

// NormalizeNetwork converts network aliases to standard names
func NormalizeNetwork(network string) string <span class="cov0" title="0">{
        if normalized, ok := NetworkAliasMap[network]; ok </span><span class="cov0" title="0">{
                return normalized
        }</span>
        <span class="cov0" title="0">return network</span>
}

// SupportedCurrencies contains all valid currency tokens
var SupportedCurrencies = []string{
        "USDT",
        "USDC",
}

// AllSupportedCurrencies returns all valid currency strings
var AllSupportedCurrencies = []string{
        USDT_ERC20,
        USDT_TRC20,
        USDT_BEP20,
        USDC_ERC20,
        USDC_TRC20,
        USDC_BEP20,
}

// CurrencyLabelMap provides display labels for currencies
var CurrencyLabelMap = map[string]string{
        USDT_ERC20: "USDT (ERC20)",
        USDT_TRC20: "USDT (TRC20)",
        USDT_BEP20: "USDT (BEP20)",
        USDC_ERC20: "USDC (ERC20)",
        USDC_TRC20: "USDC (TRC20)",
        USDC_BEP20: "USDC (BEP20)",
}

// NetworkFromCurrency extracts the network part from currency (e.g., "ERC20" from "USDT_ERC20")
// For single-token formats like "ETH", returns an empty string
func NetworkFromCurrency(currency string) string <span class="cov8" title="1">{
        parts := strings.SplitN(currency, "_", 2)
        if len(parts) == 2 </span><span class="cov8" title="1">{
                return parts[1]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// TokenFromCurrency extracts the token part from currency (e.g., "USDT" from "USDT_ERC20")
func TokenFromCurrency(currency string) string <span class="cov8" title="1">{
        parts := strings.SplitN(currency, "_", 2)
        if len(parts) &gt;= 1 </span><span class="cov8" title="1">{
                return parts[0]
        }</span>
        <span class="cov0" title="0">return currency</span>
}

// IsValid checks if the currency format is valid (TOKEN_NETWORK)
func IsValid(currency string) bool <span class="cov8" title="1">{
        if currency == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if it's in the supported list
        <span class="cov8" title="1">for _, c := range AllSupportedCurrencies </span><span class="cov8" title="1">{
                if c == currency </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// BuildCurrency creates a currency string from token and network
func BuildCurrency(token, network string) string <span class="cov8" title="1">{
        return token + "_" + network
}</span>

// FormatForDisplay returns a human-readable label for the currency
func FormatForDisplay(currency string) string <span class="cov8" title="1">{
        if label, ok := CurrencyLabelMap[currency]; ok </span><span class="cov8" title="1">{
                return label
        }</span>
        <span class="cov8" title="1">return currency</span>
}

// SupportedCurrenciesOptions returns frontend options for currency selection
func SupportedCurrenciesOptions() []struct {
        Value string
        Label string
} <span class="cov8" title="1">{
        options := make([]struct {
                Value string
                Label string
        }, len(AllSupportedCurrencies))

        for i, c := range AllSupportedCurrencies </span><span class="cov8" title="1">{
                options[i] = struct {
                        Value string
                        Label string
                }{
                        Value: c,
                        Label: CurrencyLabelMap[c],
                }
        }</span>
        <span class="cov8" title="1">return options</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package db

import (
        "database/sql"
        "log"

        _ "github.com/jackc/pgx/v5/stdlib"
)

func InitDB(databaseURL string) (*sql.DB, error) <span class="cov0" title="0">{
        db, err := sql.Open("pgx", databaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(300)

        if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, err
        }</span>

        <span class="cov0" title="0">log.Println("Database connected successfully (using pgx driver)")
        return db, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// internal/docs/swagger.go
package docs

import "github.com/swaggo/swag"

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = struct {
        Version     string
        Host        string
        BasePath    string
        Schemes     []string
        Title       string
        Description string
}{
        Version:     "1.0",
        Host:        "api.monera-digital.com",
        BasePath:    "/api",
        Schemes:     []string{"https"},
        Title:       "MoneraDigital API",
        Description: "Institutional-grade digital asset platform API",
}

// swaggerInstanceName is the registered swag instance name
const swaggerInstanceName = "swagger"

// NewSwagger initializes the swagger documentation
func NewSwagger() <span class="cov0" title="0">{
        swag.Register(swaggerInstanceName, &amp;swag.Spec{
                Version:          SwaggerInfo.Version,
                Host:             SwaggerInfo.Host,
                BasePath:         SwaggerInfo.BasePath,
                Schemes:          SwaggerInfo.Schemes,
                Title:            SwaggerInfo.Title,
                Description:      SwaggerInfo.Description,
                InfoInstanceName: swaggerInstanceName,
                SwaggerTemplate:  swaggerTemplate,
        })
}</span>

// GetSwaggerInstanceName returns the swag instance name
func GetSwaggerInstanceName() string <span class="cov0" title="0">{
        return swaggerInstanceName
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "monera-digital/internal/account"
        "monera-digital/internal/dto"
        "monera-digital/internal/logger"

        "github.com/gin-gonic/gin"
)

// AccountHandler handles requests for the external account system.
// @title Account System API
// @description API for interacting with the external account system
// @version 1.0
// @host api.monera-digital.com
// @basePath /api
// @schemes https
type AccountHandler struct {
        Client *account.Client
}

// NewAccountHandler creates a new AccountHandler.
// @Summary Get user accounts
// @Description Retrieves all accounts for a given user
// @Tags accounts
// @Accept json
// @Produce json
// @Param userId query string true "User ID"
// @Success 200 {object} dto.GetUserAccountsResponse
// @Router /accounts [get]
func (h *AccountHandler) GetUserAccounts(c *gin.Context) <span class="cov0" title="0">{
        // Parse userId from query
        userID := c.Query("userId")
        if userID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "missing userId parameter"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Client.GetUserAccounts(c.Request.Context(), dto.GetUserAccountsRequest{UserID: userID})
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get user accounts", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// CreateAccount handles POST /accounts
// @Summary Create a new account
// @Description Creates a new account for a user
// @Tags accounts
// @Accept json
// @Produce json
// @Param request body dto.CreateAccountRequest true "Create Account Request"
// @Success 200 {object} dto.CreateAccountResponse
// @Router /accounts [post]
func (h *AccountHandler) CreateAccount(c *gin.Context) <span class="cov0" title="0">{
        var req dto.CreateAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Client.CreateAccount(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to create account", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// GetAccountHistory handles GET /accounts/history
// @Summary Get account history
// @Description Retrieves transaction history for an account
// @Tags accounts
// @Accept json
// @Produce json
// @Param accountId query string true "Account ID"
// @Param userId query string true "User ID"
// @Param currency query string false "Currency"
// @Param startTime query string false "Start Time"
// @Param endTime query string false "End Time"
// @Param page query int false "Page number"
// @Param size query int false "Page size"
// @Success 200 {object} dto.GetAccountHistoryResponse
// @Router /accounts/history [get]
func (h *AccountHandler) GetAccountHistory(c *gin.Context) <span class="cov0" title="0">{
        // Parse query params
        accountID := c.Query("accountId")
        userID := c.Query("userId")
        currency := c.Query("currency")
        startTime := c.Query("startTime")
        endTime := c.Query("endTime")

        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        size, _ := strconv.Atoi(c.DefaultQuery("size", "20"))

        req := dto.GetAccountHistoryRequest{
                AccountID: accountID,
                UserID:    userID,
                Currency:  currency,
                StartTime: startTime,
                EndTime:   endTime,
                Page:      page,
                Size:      size,
        }

        resp, err := h.Client.GetAccountHistory(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to get account history", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// FreezeBalance handles POST /accounts/freeze
// @Summary Freeze balance
// @Description Freezes a specified amount in an account
// @Tags accounts
// @Accept json
// @Produce json
// @Param request body dto.FreezeBalanceRequest true "Freeze Balance Request"
// @Success 200 {object} dto.FreezeBalanceResponse
// @Router /accounts/freeze [post]
func (h *AccountHandler) FreezeBalance(c *gin.Context) <span class="cov0" title="0">{
        var req dto.FreezeBalanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Client.FreezeBalance(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to freeze balance", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// UnfreezeBalance handles POST /accounts/unfreeze
// @Summary Unfreeze balance
// @Description Unfreezes a specified amount in an account
// @Tags accounts
// @Accept json
// @Produce json
// @Param request body dto.UnfreezeBalanceRequest true "Unfreeze Balance Request"
// @Success 200 {object} dto.UnfreezeBalanceResponse
// @Router /accounts/unfreeze [post]
func (h *AccountHandler) UnfreezeBalance(c *gin.Context) <span class="cov0" title="0">{
        var req dto.UnfreezeBalanceRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Client.UnfreezeBalance(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to unfreeze balance", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}

// Transfer handles POST /accounts/transfer
// @Summary Transfer funds
// @Description Moves funds between two accounts
// @Tags accounts
// @Accept json
// @Produce json
// @Param request body dto.TransferRequest true "Transfer Request"
// @Success 200 {object} dto.TransferResponse
// @Router /accounts/transfer [post]
func (h *AccountHandler) Transfer(c *gin.Context) <span class="cov0" title="0">{
        var req dto.TransferRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.Client.Transfer(c.Request.Context(), req)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to transfer", "error", err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": "internal server error"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, resp)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

// BaseHandler 封装通用的 HTTP 处理逻辑
type BaseHandler struct{}

// getUserID 从上下文中获取用户 ID
func (h *BaseHandler) getUserID(c *gin.Context) (int, bool) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">id, ok := userID.(int)
        return id, ok</span>
}

// getUserEmail 从上下文中获取用户邮箱
func (h *BaseHandler) getUserEmail(c *gin.Context) (string, bool) <span class="cov8" title="1">{
        email, exists := c.Get("email")
        if !exists </span><span class="cov8" title="1">{
                return "", false
        }</span>
        <span class="cov8" title="1">emailStr, ok := email.(string)
        return emailStr, ok</span>
}

// requireUserID 确保用户已认证，未认证返回 401
func (h *BaseHandler) requireUserID(c *gin.Context) (int, bool) <span class="cov8" title="1">{
        id, ok := h.getUserID(c)
        if !ok </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "Unauthorized",
                        "code":  "AUTH_REQUIRED",
                })
                return 0, false
        }</span>
        <span class="cov8" title="1">return id, true</span>
}

// bindTokenRequest 绑定并验证 TOTP token 请求
func (h *BaseHandler) bindTokenRequest(c *gin.Context) (string, bool) <span class="cov8" title="1">{
        var req struct {
                Token string `json:"token" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Token is required",
                        "code":  "INVALID_REQUEST",
                })
                return "", false
        }</span>

        <span class="cov8" title="1">if len(req.Token) != 6 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "Token must be 6 digits",
                        "code":  "INVALID_TOKEN_FORMAT",
                })
                return "", false
        }</span>

        <span class="cov8" title="1">return req.Token, true</span>
}

// successResponse 返回成功响应
func (h *BaseHandler) successResponse(c *gin.Context, data interface{}) <span class="cov8" title="1">{
        c.JSON(http.StatusOK, gin.H{
                "success": true,
                "data":    data,
        })
}</span>

// errorResponse 返回错误响应
func (h *BaseHandler) errorResponse(c *gin.Context, status int, code string, message string) <span class="cov8" title="1">{
        c.JSON(status, gin.H{
                "success": false,
                "error": gin.H{
                        "code":    code,
                        "message": message,
                },
        })
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package core

import (
        "encoding/json"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// Status constants for CoreAccount
type CoreAccountStatus string

const (
        StatusCreating   CoreAccountStatus = "CREATING"
        StatusPendingKYC CoreAccountStatus = "PENDING_KYC"
        StatusActive     CoreAccountStatus = "ACTIVE"
        StatusSuspended  CoreAccountStatus = "SUSPENDED"
        StatusClosed     CoreAccountStatus = "CLOSED"
        StatusRejected   CoreAccountStatus = "REJECTED"
)

// KYCStatus constants
type KYCStatus string

const (
        KYCNotSubmitted KYCStatus = "NOT_SUBMITTED"
        KYCPending      KYCStatus = "PENDING"
        KYCInReview     KYCStatus = "IN_REVIEW"
        KYCVerified     KYCStatus = "VERIFIED"
        KYCRejected     KYCStatus = "REJECTED"
)

// AccountType constants
type AccountType string

const (
        TypeIndividual AccountType = "INDIVIDUAL"
        TypeCorporate  AccountType = "CORPORATE"
)

// CoreAccount represents the core account model
type CoreAccount struct {
        AccountID   string            `json:"accountId"`
        ExternalID  string            `json:"externalId"`
        AccountType AccountType       `json:"accountType"`
        Status      CoreAccountStatus `json:"status"`
        Profile     AccountProfile    `json:"profile"`
        KYCStatus   KYCStatus         `json:"kycStatus"`
        KYCLevel    int               `json:"kycLevel"`
        WalletIDs   []string          `json:"walletIds"`
        Metadata    map[string]any    `json:"metadata"`
        CreatedAt   time.Time         `json:"createdAt"`
        UpdatedAt   time.Time         `json:"updatedAt"`
}

// AccountProfile represents user profile information
type AccountProfile struct {
        Email       string   `json:"email"`
        Phone       string   `json:"phone"`
        FirstName   string   `json:"firstName"`
        LastName    string   `json:"lastName"`
        DateOfBirth string   `json:"dateOfBirth"`
        Nationality string   `json:"nationality"`
        Address     *Address `json:"address,omitempty"`
}

// Address represents a physical address
type Address struct {
        Street     string `json:"street"`
        City       string `json:"city"`
        State      string `json:"state"`
        PostalCode string `json:"postalCode"`
        Country    string `json:"country"`
}

// CreateAccountRequest represents the request body for account creation
type CreateAccountRequest struct {
        ExternalID  string         `json:"externalId"`
        AccountType AccountType    `json:"accountType"`
        Profile     AccountProfile `json:"profile"`
        Metadata    map[string]any `json:"metadata"`
}

// UpdateStatusRequest represents the request body for status update
type UpdateStatusRequest struct {
        Status CoreAccountStatus `json:"status"`
        Reason string            `json:"reason"`
}

// SubmitKYCRequest represents the request body for KYC submission
type SubmitKYCRequest struct {
        DocumentType       string `json:"documentType"`
        DocumentNumber     string `json:"documentNumber"`
        DocumentFrontImage string `json:"documentFrontImage"`
        DocumentBackImage  string `json:"documentBackImage"`
        SelfieImage        string `json:"selfieImage"`
}

// KYCDocument represents a KYC document
type KYCDocument struct {
        Type        string     `json:"type"`
        Status      string     `json:"status"`
        SubmittedAt time.Time  `json:"submittedAt"`
        VerifiedAt  *time.Time `json:"verifiedAt,omitempty"`
}

// KYCStatusResponse represents the KYC status response
type KYCStatusResponse struct {
        AccountID        string        `json:"accountId"`
        KYCStatus        KYCStatus     `json:"kycStatus"`
        KYCLevel         int           `json:"kycLevel"`
        VerificationDate time.Time     `json:"verificationDate"`
        ExpiresAt        time.Time     `json:"expiresAt"`
        Documents        []KYCDocument `json:"documents"`
}

// Response represents the standard API response
type Response struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   *ErrorInfo  `json:"error,omitempty"`
        Meta    Meta        `json:"meta"`
}

// Meta represents response metadata
type Meta struct {
        RequestID string `json:"requestId"`
        Timestamp int64  `json:"timestamp"`
}

// ErrorInfo represents error details
type ErrorInfo struct {
        Code    string            `json:"code"`
        Message string            `json:"message"`
        Details map[string]string `json:"details,omitempty"`
}

// InMemoryStore provides thread-safe in-memory storage for accounts
type InMemoryStore struct {
        mu       sync.RWMutex
        accounts map[string]*CoreAccount
}

// Global store instance
var store = &amp;InMemoryStore{
        accounts: make(map[string]*CoreAccount),
}

// GetAccount retrieves an account by its ID
func (s *InMemoryStore) GetAccount(accountID string) (*CoreAccount, bool) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        account, exists := s.accounts[accountID]
        return account, exists
}</span>

// GetAccountByExternalID retrieves an account by external ID
func (s *InMemoryStore) GetAccountByExternalID(externalID string) (*CoreAccount, bool) <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        for _, account := range s.accounts </span><span class="cov0" title="0">{
                if account.ExternalID == externalID </span><span class="cov0" title="0">{
                        return account, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}

// CreateAccount stores a new account
func (s *InMemoryStore) CreateAccount(account *CoreAccount) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.accounts[account.AccountID] = account
}</span>

// UpdateAccount updates an existing account with a custom function
func (s *InMemoryStore) UpdateAccount(accountID string, updateFn func(*CoreAccount)) <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()
        if account, exists := s.accounts[accountID]; exists </span><span class="cov0" title="0">{
                updateFn(account)
        }</span>
}

// Handler provides HTTP handlers for core account operations
type Handler struct{}

// NewHandler creates a new Handler instance
func NewHandler() *Handler <span class="cov0" title="0">{
        return &amp;Handler{}
}</span>

// createResponse is a helper to create standardized responses
func createResponse(data interface{}, err *ErrorInfo) Response <span class="cov0" title="0">{
        return Response{
                Success: err == nil,
                Data:    data,
                Error:   err,
                Meta: Meta{
                        RequestID: uuid.New().String(),
                        Timestamp: time.Now().Unix(),
                },
        }
}</span>

// newError creates an ErrorInfo with the given code and message
func newError(code, message string, details map[string]string) *ErrorInfo <span class="cov0" title="0">{
        return &amp;ErrorInfo{
                Code:    code,
                Message: message,
                Details: details,
        }
}</span>

// CreateAccount handles POST /api/core/accounts/create
func (h *Handler) CreateAccount(c *gin.Context) <span class="cov0" title="0">{
        var req CreateAccountRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, createResponse(nil, newError("INVALID_REQUEST", "Invalid request parameters", map[string]string{"error": err.Error()})))
                return
        }</span>

        // Check for duplicate external ID
        <span class="cov0" title="0">if existing, _ := store.GetAccountByExternalID(req.ExternalID); existing != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, createResponse(nil, newError("ACCOUNT_EXISTS", "Account already exists", map[string]string{"externalId": req.ExternalID})))
                return
        }</span>

        // Simulate network latency (can be removed in production)
        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

        // Create new account
        now := time.Now()
        accountID := "core_" + uuid.New().String()[:32]
        account := &amp;CoreAccount{
                AccountID:   accountID,
                ExternalID:  req.ExternalID,
                AccountType: req.AccountType,
                Status:      StatusCreating,
                Profile:     req.Profile,
                KYCStatus:   KYCNotSubmitted,
                KYCLevel:    0,
                WalletIDs:   []string{},
                Metadata:    req.Metadata,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        store.CreateAccount(account)

        // Trigger async KYC workflow
        go func() </span><span class="cov0" title="0">{
                // Move to PENDING_KYC after 2 seconds
                time.Sleep(2 * time.Second)
                store.UpdateAccount(accountID, func(acc *CoreAccount) </span><span class="cov0" title="0">{
                        acc.Status = StatusPendingKYC
                        acc.UpdatedAt = time.Now()
                }</span>)

                // Approve KYC after additional 5 seconds
                <span class="cov0" title="0">time.Sleep(5 * time.Second)
                store.UpdateAccount(accountID, func(acc *CoreAccount) </span><span class="cov0" title="0">{
                        acc.Status = StatusActive
                        acc.KYCStatus = KYCVerified
                        acc.KYCLevel = 2
                        acc.UpdatedAt = time.Now()
                }</span>)
        }()

        <span class="cov0" title="0">c.JSON(http.StatusCreated, createResponse(account, nil))</span>
}

// GetAccount handles GET /api/core/accounts/:accountId
func (h *Handler) GetAccount(c *gin.Context) <span class="cov0" title="0">{
        accountID := c.Param("accountId")
        if accountID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, createResponse(nil, newError("INVALID_REQUEST", "Account ID is required", nil)))
                return
        }</span>

        <span class="cov0" title="0">account, exists := store.GetAccount(accountID)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, createResponse(nil, newError("ACCOUNT_NOT_FOUND", "Account not found", map[string]string{"accountId": accountID})))
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, createResponse(account, nil))</span>
}

// UpdateStatus handles PUT /api/core/accounts/:accountId/status
func (h *Handler) UpdateStatus(c *gin.Context) <span class="cov0" title="0">{
        accountID := c.Param("accountId")

        var req UpdateStatusRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, createResponse(nil, newError("INVALID_REQUEST", "Invalid request parameters", nil)))
                return
        }</span>

        <span class="cov0" title="0">_, exists := store.GetAccount(accountID)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, createResponse(nil, newError("ACCOUNT_NOT_FOUND", "Account not found", nil)))
                return
        }</span>

        <span class="cov0" title="0">store.UpdateAccount(accountID, func(acc *CoreAccount) </span><span class="cov0" title="0">{
                acc.Status = req.Status
                acc.UpdatedAt = time.Now()
        }</span>)

        <span class="cov0" title="0">c.JSON(http.StatusOK, createResponse(map[string]interface{}{
                "accountId": accountID,
                "status":    req.Status,
                "reason":    req.Reason,
                "updatedAt": time.Now(),
        }, nil))</span>
}

// SubmitKYC handles POST /api/core/accounts/:accountId/kyc/submit
func (h *Handler) SubmitKYC(c *gin.Context) <span class="cov0" title="0">{
        accountID := c.Param("accountId")

        var req SubmitKYCRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, createResponse(nil, newError("INVALID_REQUEST", "Invalid request parameters", nil)))
                return
        }</span>

        <span class="cov0" title="0">_, exists := store.GetAccount(accountID)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, createResponse(nil, newError("ACCOUNT_NOT_FOUND", "Account not found", nil)))
                return
        }</span>

        <span class="cov0" title="0">store.UpdateAccount(accountID, func(acc *CoreAccount) </span><span class="cov0" title="0">{
                acc.KYCStatus = KYCPending
                acc.UpdatedAt = time.Now()
        }</span>)

        <span class="cov0" title="0">c.JSON(http.StatusOK, createResponse(map[string]interface{}{
                "accountId":       accountID,
                "kycStatus":       "PENDING",
                "documentType":    req.DocumentType,
                "submittedAt":     time.Now(),
                "estimatedReview": "24-48 hours",
        }, nil))</span>
}

// GetKYCStatus handles GET /api/core/accounts/:accountId/kyc/status
func (h *Handler) GetKYCStatus(c *gin.Context) <span class="cov0" title="0">{
        accountID := c.Param("accountId")

        account, exists := store.GetAccount(accountID)
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, createResponse(nil, newError("ACCOUNT_NOT_FOUND", "Account not found", nil)))
                return
        }</span>

        <span class="cov0" title="0">response := KYCStatusResponse{
                AccountID:        accountID,
                KYCStatus:        account.KYCStatus,
                KYCLevel:         account.KYCLevel,
                VerificationDate: time.Now(),
                ExpiresAt:        time.Now().AddDate(1, 0, 0),
                Documents: []KYCDocument{
                        {
                                Type:        "PASSPORT",
                                Status:      string(account.KYCStatus),
                                SubmittedAt: account.CreatedAt,
                                VerifiedAt:  func() *time.Time </span><span class="cov0" title="0">{ t := time.Now(); return &amp;t }</span>(),
                        },
                },
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, createResponse(response, nil))</span>
}

// SetupRoutes configures the core account API routes
func SetupRoutes(router *gin.Engine) <span class="cov0" title="0">{
        handler := NewHandler()

        core := router.Group("/api/core")
        </span><span class="cov0" title="0">{
                accounts := core.Group("/accounts")
                </span><span class="cov0" title="0">{
                        accounts.POST("/create", handler.CreateAccount)
                        accounts.GET("/:accountId", handler.GetAccount)
                        accounts.PUT("/:accountId/status", handler.UpdateStatus)

                        kyc := accounts.Group("/:accountId/kyc")
                        </span><span class="cov0" title="0">{
                                kyc.POST("/submit", handler.SubmitKYC)
                                kyc.GET("/status", handler.GetKYCStatus)
                        }</span>
                }
        }

        <span class="cov0" title="0">router.GET("/api/core/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{
                        "status":    "healthy",
                        "timestamp": time.Now().Unix(),
                })
        }</span>)
}

// GetStore returns the global store instance (for testing)
func GetStore() *InMemoryStore <span class="cov0" title="0">{
        return store
}</span>

// ClearStore clears all accounts (for testing)
func ClearStore() <span class="cov0" title="0">{
        store.mu.Lock()
        defer store.mu.Unlock()
        store.accounts = make(map[string]*CoreAccount)
}</span>

// ExportAccountAsJSON exports an account as formatted JSON (for testing)
func ExportAccountAsJSON(accountID string) (string, bool) <span class="cov0" title="0">{
        account, exists := store.GetAccount(accountID)
        if !exists </span><span class="cov0" title="0">{
                return "", false
        }</span>
        <span class="cov0" title="0">data, _ := json.MarshalIndent(account, "", "  ")
        return string(data), true</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package handlers

import (
        "github.com/gin-gonic/gin"
        "net/http"
        "strconv"
)

func (h *Handler) GetDeposits(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">limit := 20
        offset := 0
        if l, err := strconv.Atoi(c.Query("limit")); err == nil &amp;&amp; l &gt; 0 </span><span class="cov0" title="0">{
                limit = l
        }</span>
        <span class="cov0" title="0">if o, err := strconv.Atoi(c.Query("offset")); err == nil &amp;&amp; o &gt;= 0 </span><span class="cov0" title="0">{
                offset = o
        }</span>

        <span class="cov0" title="0">deposits, total, err := h.DepositService.GetDeposits(c.Request.Context(), userID.(int), limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                c.Error(err)
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "total":    total,
                "deposits": deposits,
        })</span>
}

func (h *Handler) HandleDepositWebhook(c *gin.Context) <span class="cov0" title="0">{
        // Webhook logic
        // Verify signature
        // Call service
        c.JSON(http.StatusOK, gin.H{"success": true})
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package handlers

import (
        "errors"
        "fmt"
        "net/http"
        "strconv"

        "github.com/gin-gonic/gin"

        "monera-digital/internal/dto"
        "monera-digital/internal/models"
        "monera-digital/internal/services"
        "monera-digital/internal/validator"
)

const (
        minDurationDays = 30
        maxDurationDays = 360
)

var supportedAssets = map[string]bool{
        "BTC":  true,
        "ETH":  true,
        "USDT": true,
        "USDC": true,
        "SOL":  true,
}

// Handler contains all HTTP handlers
type Handler struct {
        AuthService       *services.AuthService
        LendingService    *services.LendingService
        AddressService    *services.AddressService
        WithdrawalService *services.WithdrawalService
        DepositService    *services.DepositService
        WalletService     *services.WalletService
        WealthService     *services.WealthService
        Validator         validator.Validator
}

func NewHandler(auth *services.AuthService, lending *services.LendingService, address *services.AddressService, withdrawal *services.WithdrawalService, deposit *services.DepositService, wallet *services.WalletService, wealth *services.WealthService) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                AuthService:       auth,
                LendingService:    lending,
                AddressService:    address,
                WithdrawalService: withdrawal,
                DepositService:    deposit,
                WalletService:     wallet,
                WealthService:     wealth,
                Validator:         validator.NewValidator(),
        }
}</span>

// Auth handlers

func (h *Handler) Login(c *gin.Context) <span class="cov8" title="1">{
        var req dto.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.Validator.ValidateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.AuthService.Login(models.LoginRequest{
                Email:    req.Email,
                Password: req.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dtoResp := dto.LoginResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
                TokenType:    resp.TokenType,
                ExpiresIn:    resp.ExpiresIn,
                ExpiresAt:    resp.ExpiresAt,
                Token:        resp.Token,
                Requires2FA:  resp.Requires2FA,
                UserID:       resp.UserID,
        }
        if resp.User != nil </span><span class="cov0" title="0">{
                dtoResp.User = &amp;dto.UserInfo{
                        ID:               resp.User.ID,
                        Email:            resp.User.Email,
                        TwoFactorEnabled: resp.User.TwoFactorEnabled,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dtoResp)</span>
}

func (h *Handler) Register(c *gin.Context) <span class="cov8" title="1">{
        var req dto.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.Validator.ValidateEmail(req.Email); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>
        <span class="cov0" title="0">if err := h.Validator.ValidatePassword(req.Password); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.AuthService.Register(models.RegisterRequest{
                Email:    req.Email,
                Password: req.Password,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, dto.UserInfo{
                ID:               user.ID,
                Email:            user.Email,
                TwoFactorEnabled: user.TwoFactorEnabled,
        })</span>
}

func (h *Handler) GetMe(c *gin.Context) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
                return
        }</span>

        <span class="cov8" title="1">user, err := h.AuthService.GetUserByID(userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user profile"})
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, dto.UserInfo{
                ID:               user.ID,
                Email:            user.Email,
                TwoFactorEnabled: user.TwoFactorEnabled,
        })</span>
}

// Verify2FALogin verifies 2FA token during login and completes authentication
func (h *Handler) Verify2FALogin(c *gin.Context) <span class="cov0" title="0">{
        var req models.Verify2FARequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">resp, err := h.AuthService.Verify2FAAndLogin(req.UserID, req.Token)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dtoResp := dto.LoginResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
                TokenType:    resp.TokenType,
                ExpiresIn:    resp.ExpiresIn,
                ExpiresAt:    resp.ExpiresAt,
                Token:        resp.Token,
                User: &amp;dto.UserInfo{
                        ID:               resp.User.ID,
                        Email:            resp.User.Email,
                        TwoFactorEnabled: resp.User.TwoFactorEnabled,
                },
        }

        c.JSON(http.StatusOK, dtoResp)</span>
}

// Skip2FALogin allows users to skip 2FA setup during login if not mandatory
func (h *Handler) Skip2FALogin(c *gin.Context) <span class="cov8" title="1">{
        var req struct {
                UserID int `json:"userId" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": err.Error(),
                        "code": "INVALID_REQUEST",
                        "userId": req.UserID,
                })
                return
        }</span>

        <span class="cov8" title="1">resp, err := h.AuthService.Skip2FAAndLogin(req.UserID)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": err.Error(),
                        "code": "SKIP_2FA_FAILED",
                        "userId": req.UserID,
                })
                return
        }</span>

        <span class="cov8" title="1">dtoResp := dto.LoginResponse{
                AccessToken:  resp.AccessToken,
                RefreshToken: resp.RefreshToken,
                TokenType:    resp.TokenType,
                ExpiresIn:    resp.ExpiresIn,
                ExpiresAt:    resp.ExpiresAt,
                Token:        resp.Token,
                User: &amp;dto.UserInfo{
                        ID:               resp.User.ID,
                        Email:            resp.User.Email,
                        TwoFactorEnabled: resp.User.TwoFactorEnabled,
                },
        }

        c.JSON(http.StatusOK, dtoResp)</span>
}

func (h *Handler) RefreshToken(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Token refresh not yet implemented"})
}</span>

func (h *Handler) Logout(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Logout not yet implemented"})
}</span>

// Lending handlers

func (h *Handler) ApplyForLending(c *gin.Context) <span class="cov8" title="1">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">var req dto.ApplyLendingRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov8" title="1">if req.Amount &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Amount must be positive"})
                return
        }</span>
        <span class="cov8" title="1">if req.DurationDays &lt; minDurationDays || req.DurationDays &gt; maxDurationDays </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{"error": fmt.Sprintf("Duration must be between %d and %d days", minDurationDays, maxDurationDays)})
                return
        }</span>
        <span class="cov8" title="1">if !supportedAssets[req.Asset] </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Unsupported asset. Supported assets: BTC, ETH, USDT, USDC, SOL"})
                return
        }</span>

        <span class="cov8" title="1">position, err := h.LendingService.ApplyForLending(userID, models.ApplyLendingRequest{
                Asset:        req.Asset,
                Amount:       fmt.Sprintf("%.8f", req.Amount),
                DurationDays: req.DurationDays,
        })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, toLendingPositionResponse(position))</span>
}

func (h *Handler) GetUserPositions(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">positions, err := h.LendingService.GetUserPositions(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">dtoPositions := make([]dto.LendingPositionResponse, len(positions))
        for i, pos := range positions </span><span class="cov0" title="0">{
                dtoPositions[i] = toLendingPositionResponse(&amp;pos)
        }</span>

        <span class="cov0" title="0">total := 0.0
        for _, pos := range dtoPositions </span><span class="cov0" title="0">{
                total += pos.AccruedYield
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dto.LendingPositionsListResponse{
                Positions: dtoPositions,
                Total:     int(total),
                Count:     len(dtoPositions),
        })</span>
}

// Address handlers

func (h *Handler) GetAddresses(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">addresses, err := h.AddressService.GetAddresses(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        // Convert models to DTOs for consistent API response format
        <span class="cov0" title="0">response := make([]dto.WithdrawalAddressResponse, len(addresses))
        for i, addr := range addresses </span><span class="cov0" title="0">{
                response[i] = dto.WithdrawalAddressResponse{
                        ID:         addr.ID,
                        UserID:     addr.UserID,
                        Address:    addr.WalletAddress,
                        Type:       addr.ChainType,
                        Label:      addr.AddressAlias,
                        IsVerified: addr.Verified,
                        IsDeleted:  addr.IsDeleted,
                        CreatedAt:  addr.CreatedAt,
                }
                // Handle nullable VerifiedAt
                if addr.VerifiedAt.Valid </span><span class="cov0" title="0">{
                        response[i].VerifiedAt = &amp;addr.VerifiedAt.Time
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"addresses": response, "total": len(response), "count": len(response)})</span>
}

func (h *Handler) AddAddress(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var req models.AddAddressRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">addr, err := h.AddressService.AddAddress(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "address already exists" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "Address already exists"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusCreated, addr)</span>
}

func (h *Handler) VerifyAddress(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid Address ID"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Token string `json:"token" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Verification token is required"})
                return
        }</span>

        // Get User to check 2FA status
        <span class="cov0" title="0">user, err := h.AuthService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user profile"})
                return
        }</span>

        <span class="cov0" title="0">verificationMethod := "EMAIL"

        if user.TwoFactorEnabled </span><span class="cov0" title="0">{
                // Verify 2FA
                valid, err := h.AuthService.Verify2FA(userID, req.Token)
                if err != nil </span><span class="cov0" title="0">{
                        // Log the specific error for debugging
                        fmt.Printf("[VerifyAddress] 2FA verification error for user %d: %v\n", userID, err)
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify 2FA: " + err.Error()})
                        return
                }</span>
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid 2FA code"})
                        return
                }</span>
                <span class="cov0" title="0">verificationMethod = "2FA"</span>
        }

        // If 2FA is not enabled, we assume the token is an email verification token.
        // However, since the current AddressService implementation doesn't verify the email token (it's a stub or assumes success),
        // and we are focusing on fixing the 2FA flow, we proceed.
        // Ideally, we should have h.AddressService.VerifyEmailToken(token) here.

        <span class="cov0" title="0">if err := h.AddressService.VerifyAddress(c.Request.Context(), userID, id, verificationMethod); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[VerifyAddress] Address verification error for user %d, address %d: %v\n", userID, id, err)
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Address verified successfully"})</span>
}

func (h *Handler) SetPrimaryAddress(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusNotImplemented, gin.H{"error": "Not implemented"})
}</span>

func (h *Handler) DeactivateAddress(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.AddressService.DeleteAddress(c.Request.Context(), userID, id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Address deleted"})</span>
}

// Withdrawal handlers

func (h *Handler) GetWithdrawals(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">orders, err := h.WithdrawalService.GetWithdrawalHistory(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"withdrawals": orders, "total": len(orders), "count": len(orders)})</span>
}

func (h *Handler) CreateWithdrawal(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateWithdrawalRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        // Get user to check if 2FA is enabled
        <span class="cov0" title="0">user, err := h.AuthService.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch user profile"})
                return
        }</span>

        // Verify 2FA if enabled
        <span class="cov0" title="0">if user.TwoFactorEnabled </span><span class="cov0" title="0">{
                valid, err := h.AuthService.Verify2FA(userID, req.TwoFactorToken)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to verify 2FA"})
                        return
                }</span>
                <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid 2FA code"})
                        return
                }</span>
        }

        <span class="cov0" title="0">order, err := h.WithdrawalService.CreateWithdrawal(c.Request.Context(), userID, req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"message": "Withdrawal created", "order": order})</span>
}

func (h *Handler) GetWithdrawalByID(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">id, err := strconv.Atoi(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "Invalid ID"})
                return
        }</span>

        <span class="cov0" title="0">order, err := h.WithdrawalService.GetWithdrawalByID(c.Request.Context(), userID, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errors.New("unauthorized")) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, order)</span>
}

func (h *Handler) GetWithdrawalFees(c *gin.Context) <span class="cov0" title="0">{
        fee, received, err := h.WithdrawalService.EstimateFee(c.Request.Context(), c.Query("asset"), c.Query("chain"), c.Query("amount"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"fee": fee, "receivedAmount": received})</span>
}

func (h *Handler) GetDocs(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"message": "Docs endpoint"})
}</span>

// Helper functions

func (h *Handler) getUserID(c *gin.Context) (int, error) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                return 0, errors.New("Unauthorized")
        }</span>
        <span class="cov8" title="1">return userID.(int), nil</span>
}

func toLendingPositionResponse(position *models.LendingPosition) dto.LendingPositionResponse <span class="cov0" title="0">{
        apy, _ := strconv.ParseFloat(position.Apy, 64)
        amount, _ := strconv.ParseFloat(position.Amount, 64)
        accruedYield, _ := strconv.ParseFloat(position.AccruedYield, 64)

        return dto.LendingPositionResponse{
                ID:           position.ID,
                UserID:       position.UserID,
                Asset:        position.Asset,
                Amount:       amount,
                DurationDays: position.DurationDays,
                APY:          apy,
                Status:       string(position.Status),
                AccruedYield: accruedYield,
                StartDate:    position.StartDate,
                EndDate:      position.EndDate,
                CreatedAt:    position.StartDate,
        }
}</span>

// Assets handlers

func (h *Handler) GetAssets(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">assets, err := h.WealthService.GetAssets(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"assets": assets, "total": len(assets), "count": len(assets)})</span>
}

func (h *Handler) RefreshPrices(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{"message": "Prices refreshed successfully"})
}</span>

// Wealth handlers

func (h *Handler) GetProducts(c *gin.Context) <span class="cov0" title="0">{
        page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        products, total, err := h.WealthService.GetProducts(c.Request.Context(), page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"products": products, "total": total, "page": page, "pageSize": pageSize})</span>
}

func (h *Handler) Subscribe(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                ProductID int64  `json:"productId" binding:"required"`
                Amount    string `json:"amount" binding:"required"`
                AutoRenew bool   `json:"autoRenew"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">orderID, err := h.WealthService.Subscribe(c.Request.Context(), userID, req.ProductID, req.Amount, req.AutoRenew)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"message": "Subscription successful", "orderId": orderID})</span>
}

func (h *Handler) GetOrders(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
        pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "20"))

        orders, total, err := h.WealthService.GetOrders(c.Request.Context(), userID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"orders": orders, "total": total, "page": page, "pageSize": pageSize})</span>
}

func (h *Handler) Redeem(c *gin.Context) <span class="cov0" title="0">{
        userID, err := h.getUserID(c)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                OrderID        int64  `json:"orderId" binding:"required"`
                RedemptionType string `json:"redemptionType" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">if err := h.WealthService.Redeem(c.Request.Context(), userID, req.OrderID, req.RedemptionType); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "Redemption successful"})</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package handlers

import (
        "net/http"

        "github.com/gin-gonic/gin"

        "monera-digital/internal/services"
)

// TwoFAHandler handles 2FA HTTP endpoints
type TwoFAHandler struct {
        base         *BaseHandler
        twofaService *services.TwoFactorService
}

// NewTwoFAHandler creates a new 2FA handler
func NewTwoFAHandler(twofa *services.TwoFactorService) *TwoFAHandler <span class="cov8" title="1">{
        return &amp;TwoFAHandler{
                base:         &amp;BaseHandler{},
                twofaService: twofa,
        }
}</span>

// Setup2FA generates a new 2FA secret, QR code, and backup codes for the user
// POST /api/auth/2fa/setup
func (h *TwoFAHandler) Setup2FA(c *gin.Context) <span class="cov8" title="1">{
        userID, ok := h.base.requireUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">email, ok := h.base.getUserEmail(c)
        if !ok </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusBadRequest, "INVALID_EMAIL", "User email not found")
                return
        }</span>

        <span class="cov0" title="0">setup, err := h.twofaService.Setup(userID, email)
        if err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusInternalServerError, "SETUP_FAILED", err.Error())
                return
        }</span>

        // Ensure otpauth URL is always set (same as qrCodeUrl)
        <span class="cov0" title="0">otpauth := setup.OTPAuth
        if otpauth == "" </span><span class="cov0" title="0">{
                otpauth = setup.QRCode
        }</span>

        <span class="cov0" title="0">h.base.successResponse(c, gin.H{
                "secret":      setup.Secret,
                "qrCodeUrl":   setup.QRCode,
                "otpauth":     otpauth,
                "backupCodes": setup.BackupCodes,
                "message":     "2FA setup successful. Scan the QR code with your authenticator app.",
        })</span>

}

// Enable2FA verifies the TOTP token and enables 2FA for the user
// POST /api/auth/2fa/enable
func (h *TwoFAHandler) Enable2FA(c *gin.Context) <span class="cov8" title="1">{
        userID, ok := h.base.requireUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">token, ok := h.base.bindTokenRequest(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">if err := h.twofaService.Enable(userID, token); err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusBadRequest, "ENABLE_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.base.successResponse(c, gin.H{
                "enabled": true,
                "message": "2FA has been enabled successfully",
        })</span>
}

// Disable2FA disables 2FA for the user
// POST /api/auth/2fa/disable
func (h *TwoFAHandler) Disable2FA(c *gin.Context) <span class="cov8" title="1">{
        userID, ok := h.base.requireUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">token, ok := h.base.bindTokenRequest(c)
        if !ok </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if err := h.twofaService.Disable(userID, token); err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusBadRequest, "DISABLE_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.base.successResponse(c, gin.H{
                "enabled": false,
                "message": "2FA has been disabled successfully",
        })</span>
}

// Verify2FA verifies a 2FA token (TOTP or backup code)
// POST /api/auth/2fa/verify
func (h *TwoFAHandler) Verify2FA(c *gin.Context) <span class="cov8" title="1">{
        userID, ok := h.base.requireUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">token, ok := h.base.bindTokenRequest(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">valid, err := h.twofaService.Verify(userID, token)
        if err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusBadRequest, "VERIFY_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusUnauthorized, "INVALID_TOKEN", "Invalid verification code")
                return
        }</span>

        <span class="cov0" title="0">h.base.successResponse(c, gin.H{
                "valid":   true,
                "message": "Token is valid",
        })</span>
}

// Verify2FALogin verifies 2FA token during login and issues JWT
// POST /api/auth/2fa/verify-login
func (h *TwoFAHandler) Verify2FALogin(c *gin.Context) <span class="cov0" title="0">{
        var req struct {
                UserID int    `json:"userId" binding:"required"`
                Token  string `json:"token" binding:"required"`
        }

        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusBadRequest, "INVALID_REQUEST", err.Error())
                return
        }</span>

        // 验证2FA令牌并生成JWT - 需要通过AuthService调用
        // 因为TwoFAHandler没有直接访问AuthService的权限
        // 这需要在路由配置中处理，或者重构Handler结构
        <span class="cov0" title="0">h.base.errorResponse(c, http.StatusNotImplemented, "NOT_IMPLEMENTED", "This endpoint should be handled by AuthService")</span>
}

// Get2FAStatus returns whether 2FA is enabled for the user
// GET /api/auth/2fa/status
func (h *TwoFAHandler) Get2FAStatus(c *gin.Context) <span class="cov8" title="1">{
        userID, ok := h.base.requireUserID(c)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">enabled, err := h.twofaService.IsEnabled(userID)
        if err != nil </span><span class="cov0" title="0">{
                h.base.errorResponse(c, http.StatusInternalServerError, "STATUS_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">h.base.successResponse(c, gin.H{
                "enabled": enabled,
        })</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package handlers

import (
        "encoding/json"
        "log"
        "net/http"
        "strconv"
        "strings"
        "time"

        "monera-digital/internal/dto"
        "monera-digital/internal/models"
        "monera-digital/internal/services"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// parseTokenFromHeader extracts and parses userId from JWT token in Authorization header
func parseTokenFromHeader(authHeader string) (int, error) <span class="cov0" title="0">{
        if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return 0, jwt.ErrSignatureInvalid
        }</span>

        <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")

        token, _, err := new(jwt.Parser).ParseUnverified(tokenString, &amp;models.TokenClaims{})
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(*models.TokenClaims)
        if !ok </span><span class="cov0" title="0">{
                return 0, jwt.ErrTokenMalformed
        }</span>

        <span class="cov0" title="0">if claims.UserID == 0 </span><span class="cov0" title="0">{
                return 0, jwt.ErrTokenMalformed
        }</span>

        <span class="cov0" title="0">return claims.UserID, nil</span>
}

func (h *Handler) CreateWallet(c *gin.Context) <span class="cov8" title="1">{
        bodyBytes, err := c.GetRawData()
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "400",
                        Message:   "Failed to read request body",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">var req dto.CreateWalletRequest
        if err := json.Unmarshal(bodyBytes, &amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "400",
                        Message:   "Invalid JSON format",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // If userId not provided in request body, try to extract from JWT token in Authorization header
        <span class="cov8" title="1">if req.UserID == "" </span><span class="cov8" title="1">{
                authHeader := c.GetHeader("Authorization")
                log.Printf("Authorization header: %s", authHeader)
                if authHeader != "" </span><span class="cov0" title="0">{
                        userID, err := parseTokenFromHeader(authHeader)
                        if err == nil &amp;&amp; userID != 0 </span><span class="cov0" title="0">{
                                req.UserID = strconv.Itoa(userID)
                        }</span>
                }
        }

        // Validate required fields
        <span class="cov8" title="1">if req.UserID == "" || req.ProductCode == "" || req.Currency == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "400",
                        Message:   "userId, productCode and currency are required",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // Validate product code
        <span class="cov8" title="1">if req.ProductCode != "X_FINANCE" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "400",
                        Message:   "Invalid product code",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // Convert userId string to int
        <span class="cov8" title="1">userID, err := strconv.Atoi(req.UserID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "400",
                        Message:   "Invalid userId format",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">wallet, err := h.WalletService.CreateWallet(c.Request.Context(), userID, req.ProductCode, req.Currency)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, dto.CreateWalletResponse{
                        Code:      "WALLET_CREATE_FAILED",
                        Message:   err.Error(),
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">status := "NORMAL"
        if wallet.Status != "SUCCESS" </span><span class="cov0" title="0">{
                status = "PENDING"
        }</span>

        <span class="cov8" title="1">createdAt := wallet.CreatedAt.Format("2006-01-02 15:04:05")

        c.JSON(http.StatusOK, dto.CreateWalletResponse{
                Code:    "200",
                Message: "Success",
                Data: dto.WalletResponseData{
                        UserID:      req.UserID,
                        ProductCode: req.ProductCode,
                        Currency:    req.Currency,
                        Status:      status,
                        CreatedAt:   createdAt,
                },
                Success:   true,
                Timestamp: time.Now().UnixMilli(),
        })</span>
}

func (h *Handler) GetWalletInfo(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error":   "Unauthorized",
                        "message": "User not authenticated",
                        "code":    "UNAUTHORIZED",
                })
                return
        }</span>

        <span class="cov0" title="0">info, err := h.WalletService.GetWalletInfo(c.Request.Context(), userID.(int))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Internal Server Error",
                        "message": err.Error(),
                        "code":    "WALLET_INFO_ERROR",
                })
                return
        }</span>

        <span class="cov0" title="0">if info == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, gin.H{"status": "NONE"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, info)</span>
}

func (h *Handler) AddWalletAddress(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error":   "Unauthorized",
                        "message": "User not authenticated",
                        "code":    "UNAUTHORIZED",
                })
                return
        }</span>

        <span class="cov0" title="0">var req dto.AddWalletAddressRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Bad Request",
                        "message": err.Error(),
                        "code":    "INVALID_REQUEST",
                })
                return
        }</span>

        <span class="cov0" title="0">if req.Chain == "" || req.Token == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error":   "Bad Request",
                        "message": "chain and token are required",
                        "code":    "MISSING_FIELDS",
                })
                return
        }</span>

        <span class="cov0" title="0">wallet, err := h.WalletService.AddAddress(c.Request.Context(), userID.(int), services.AddAddressRequest{
                Chain: req.Chain,
                Token: req.Token,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Return 400 for business logic errors (wallet not found, etc.)
                errMsg := err.Error()
                if strings.Contains(errMsg, "wallet not found") </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error":   "WALLET_NOT_FOUND",
                                "message": "Please create a wallet first before adding addresses",
                                "code":    "WALLET_NOT_FOUND",
                        })
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                        "error":   "Internal Server Error",
                        "message": errMsg,
                        "code":    "ADD_ADDRESS_ERROR",
                })
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "walletId":    wallet.WalletID,
                "currency":    wallet.Currency,
                "address":     wallet.Address,
                "addressType": wallet.AddressType.String,
                "derivePath":  wallet.DerivePath.String,
                "status":      string(wallet.Status),
                "isPrimary":   wallet.IsPrimary,
                "createdAt":   wallet.CreatedAt.Format("2006-01-02 15:04:05"),
        })</span>
}

func (h *Handler) GetAddressIncomeHistory(c *gin.Context) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, dto.GetAddressIncomeHistoryResponse{
                        Code:      "401",
                        Message:   "Unauthorized",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">var req dto.GetAddressIncomeHistoryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, dto.GetAddressIncomeHistoryResponse{
                        Code:      "400",
                        Message:   "Invalid request: address is required",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // 调用 Core API 获取收入历史
        <span class="cov8" title="1">records, err := h.WalletService.GetAddressIncomeHistory(c.Request.Context(), userID.(int), req.Address)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, dto.GetAddressIncomeHistoryResponse{
                        Code:      "500",
                        Message:   "Failed to get income history: " + err.Error(),
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // 转换为 DTO 类型
        <span class="cov0" title="0">data := make([]dto.AddressIncomeRecord, len(records))
        for i, r := range records </span><span class="cov0" title="0">{
                data[i] = dto.AddressIncomeRecord{
                        TxKey:             r.TxKey,
                        TxHash:            r.TxHash,
                        CoinKey:           r.CoinKey,
                        TxAmount:          r.TxAmount,
                        Address:           r.Address,
                        TransactionStatus: r.TransactionStatus,
                        BlockHeight:       r.BlockHeight,
                        CreateTime:        r.CreateTime,
                        CompletedTime:     r.CompletedTime,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, dto.GetAddressIncomeHistoryResponse{
                Code:      "200",
                Message:   "成功",
                Data:      data,
                Success:   true,
                Timestamp: time.Now().UnixMilli(),
        })</span>
}

func (h *Handler) GetWalletAddress(c *gin.Context) <span class="cov8" title="1">{
        userID, exists := c.Get("userID")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, dto.GetWalletAddressResponse{
                        Code:      "401",
                        Message:   "Unauthorized",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">var req dto.GetWalletAddressRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, dto.GetWalletAddressResponse{
                        Code:      "400",
                        Message:   "Invalid request format",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        // 如果请求中没有 userId，从 JWT token 中获取
        <span class="cov8" title="1">if req.UserID == "" </span><span class="cov8" title="1">{
                req.UserID = strconv.Itoa(userID.(int))
        }</span>

        // 验证必填字段
        <span class="cov8" title="1">if req.UserID == "" || req.ProductCode == "" || req.Currency == "" </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, dto.GetWalletAddressResponse{
                        Code:      "400",
                        Message:   "userId, productCode and currency are required",
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">wallet, err := h.WalletService.GetWalletAddress(c.Request.Context(), userID.(int), req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, dto.GetWalletAddressResponse{
                        Code:      "500",
                        Message:   "Failed to get wallet address: " + err.Error(),
                        Success:   false,
                        Timestamp: time.Now().UnixMilli(),
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, dto.GetWalletAddressResponse{
                Code:      "200",
                Message:   "成功",
                Data:      *wallet,
                Success:   true,
                Timestamp: time.Now().UnixMilli(),
        })</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// internal/logger/logger.go
package logger

import (
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// Logger is the global sugared logger instance
var Logger *zap.SugaredLogger

// Init initializes the global logger
func Init(environment string) error <span class="cov0" title="0">{
        var config zap.Config

        if environment == "production" </span><span class="cov0" title="0">{
                config = zap.NewProductionConfig()
                config.EncoderConfig.TimeKey = "timestamp"
                config.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
        }</span> else<span class="cov0" title="0"> {
                config = zap.NewDevelopmentConfig()
                config.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        }</span>

        <span class="cov0" title="0">config.EncoderConfig.MessageKey = "message"
        config.EncoderConfig.LevelKey = "level"

        zapLogger, err := config.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">Logger = zapLogger.Sugar()
        return nil</span>
}

// GetLogger returns the global logger instance
func GetLogger() *zap.SugaredLogger <span class="cov0" title="0">{
        return Logger
}</span>

// Info logs an info message
func Info(message string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        Logger.Infow(message, keysAndValues...)
}</span>

// Warn logs a warning message
func Warn(message string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        Logger.Warnw(message, keysAndValues...)
}</span>

// Error logs an error message
func Error(message string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        Logger.Errorw(message, keysAndValues...)
}</span>

// Debug logs a debug message
func Debug(message string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        Logger.Debugw(message, keysAndValues...)
}</span>

// Fatal logs a fatal message and then exits
func Fatal(message string, keysAndValues ...interface{}) <span class="cov0" title="0">{
        Logger.Fatalw(message, keysAndValues...)
}</span>

// With creates a child logger with the given fields
func With(keysAndValues ...interface{}) *zap.SugaredLogger <span class="cov0" title="0">{
        return Logger.With(keysAndValues...)
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// internal/middleware/auth.go
package middleware

import (
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
        "monera-digital/internal/models"
)

// AuthMiddleware validates JWT tokens in Authorization header
func AuthMiddleware(jwtSecret string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, ErrorResponse{
                                Code:    "MISSING_TOKEN",
                                Message: "Authorization header is required",
                        })
                        c.Abort()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;" format
                <span class="cov0" title="0">parts := strings.Split(authHeader, " ")
                if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, ErrorResponse{
                                Code:    "INVALID_TOKEN_FORMAT",
                                Message: "Authorization header must be in 'Bearer &lt;token&gt;' format",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token := parts[1]

                // Parse and validate token
                claims := &amp;models.TokenClaims{}
                parsedToken, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        return []byte(jwtSecret), nil
                }</span>)

                <span class="cov0" title="0">if err != nil || !parsedToken.Valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, ErrorResponse{
                                Code:    "INVALID_TOKEN",
                                Message: "Token is invalid or expired",
                        })
                        c.Abort()
                        return
                }</span>

                // Check token type (if present in claims)
                <span class="cov0" title="0">if claims.TokenType != "" &amp;&amp; claims.TokenType != "access" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, ErrorResponse{
                                Code:    "INVALID_TOKEN_TYPE",
                                Message: "Token type must be 'access'",
                        })
                        c.Abort()
                        return
                }</span>

                // Store user info in context
                <span class="cov0" title="0">c.Set("userID", claims.UserID)
                c.Set("email", claims.Email)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// internal/middleware/error_handler.go
package middleware

import (
        "errors"
        "net/http"

        "github.com/gin-gonic/gin"
        "monera-digital/internal/validator"
)

// ErrorResponse represents a standardized error response
type ErrorResponse struct {
        Code    string `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// errorMapping maps error messages to HTTP responses
var errorMapping = map[string]struct {
        status int
        code   string
        msg    string
}{
        "email not found":                 {http.StatusUnauthorized, "EMAIL_NOT_FOUND", "Email input error or does not exist"},
        "invalid credentials":             {http.StatusUnauthorized, "INVALID_CREDENTIALS", "Invalid email or password"},
        "email already registered":        {http.StatusConflict, "EMAIL_ALREADY_EXISTS", "Email is already registered"},
        "invalid refresh token":           {http.StatusUnauthorized, "INVALID_REFRESH_TOKEN", "Refresh token is invalid or expired"},
        "refresh token has been revoked":  {http.StatusUnauthorized, "TOKEN_REVOKED", "Refresh token has been revoked"},
        "token blacklist not initialized": {http.StatusInternalServerError, "INTERNAL_ERROR", "Token service is not properly initialized"},
        "unauthorized":                    {http.StatusUnauthorized, "UNAUTHORIZED", "Authentication required"},
        "not found":                       {http.StatusNotFound, "NOT_FOUND", "Resource not found"},
}

// ErrorHandler middleware for handling errors consistently
func ErrorHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Next()

                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        err := c.Errors.Last()
                        handleError(c, err.Err)
                }</span>
        }
}

// handleError maps errors to appropriate HTTP status codes and responses
func handleError(c *gin.Context, err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Check for validation errors
        <span class="cov0" title="0">var validationErr *validator.ValidationError
        if errors.As(err, &amp;validationErr) </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, ErrorResponse{
                        Code:    "VALIDATION_ERROR",
                        Message: validationErr.Error(),
                        Details: validationErr.Field,
                })
                return
        }</span>

        // Check for mapped errors
        <span class="cov0" title="0">errMsg := err.Error()
        if mapping, ok := errorMapping[errMsg]; ok </span><span class="cov0" title="0">{
                c.JSON(mapping.status, ErrorResponse{
                        Code:    mapping.code,
                        Message: mapping.msg,
                })
                return
        }</span>

        // Generic internal server error
        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, ErrorResponse{
                Code:    "INTERNAL_ERROR",
                Message: "An internal server error occurred",
                Details: errMsg,
        })</span>
}

// RecoveryHandler middleware for recovering from panics
func RecoveryHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                c.JSON(http.StatusInternalServerError, ErrorResponse{
                                        Code:    "PANIC_RECOVERED",
                                        Message: "An unexpected error occurred",
                                })
                                c.Abort()
                        }</span>
                }()
                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt/v5"
)

// CORS middleware
func CORS() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Header("Access-Control-Allow-Origin", "*")
                c.Header("Access-Control-Allow-Credentials", "true")
                c.Header("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
                c.Header("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })
}

// Logger middleware
func Logger() gin.HandlerFunc <span class="cov0" title="0">{
        return gin.Logger()
}</span>

// AuthRequired middleware
func AuthRequired(jwtSecret string) gin.HandlerFunc <span class="cov0" title="0">{
        return gin.HandlerFunc(func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Authorization token required"})
                        c.Abort()
                        return
                }</span>

                // Extract token from "Bearer &lt;token&gt;"
                <span class="cov0" title="0">tokenString := strings.TrimPrefix(authHeader, "Bearer ")
                if tokenString == authHeader </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid authorization header format"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        // Validate the alg is what we expect
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(jwtSecret), nil</span>
                })

                <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid or expired token"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok </span><span class="cov0" title="0">{
                        if userID, ok := claims["user_id"].(float64); ok </span><span class="cov0" title="0">{
                                c.Set("userID", int(userID))
                                if email, ok := claims["email"].(string); ok </span><span class="cov0" title="0">{
                                        c.Set("email", email)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
                                c.Abort()
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token claims"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        })
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// internal/middleware/rate_limit.go
package middleware

import (
        "context"
        "fmt"
        "net/http"
        "sync"
        "time"

        "github.com/gin-gonic/gin"
)

// RateLimiter 速率限制器
type RateLimiter struct {
        store  map[string][]time.Time
        mu     sync.RWMutex
        limit  int
        window time.Duration
        ctx    context.Context
        cancel context.CancelFunc
}

// NewRateLimiter 创建速率限制器
func NewRateLimiter(limit int, window time.Duration) *RateLimiter <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())
        rl := &amp;RateLimiter{
                store:  make(map[string][]time.Time),
                limit:  limit,
                window: window,
                ctx:    ctx,
                cancel: cancel,
        }

        // 启动清理过期时间戳的后台任务
        go rl.cleanupExpiredTimestamps()

        return rl
}</span>

func (rl *RateLimiter) Stop() <span class="cov0" title="0">{
        rl.cancel()
}</span>

func (rl *RateLimiter) IsAllowed(key string) bool <span class="cov0" title="0">{
        rl.mu.Lock()
        defer rl.mu.Unlock()

        now := time.Now()
        timestamps := rl.store[key]

        valid := make([]time.Time, 0, len(timestamps))
        for _, ts := range timestamps </span><span class="cov0" title="0">{
                if now.Sub(ts) &lt; rl.window </span><span class="cov0" title="0">{
                        valid = append(valid, ts)
                }</span>
        }

        <span class="cov0" title="0">if len(valid) &gt;= rl.limit </span><span class="cov0" title="0">{
                rl.store[key] = valid
                return false
        }</span>

        <span class="cov0" title="0">valid = append(valid, now)
        rl.store[key] = valid
        return true</span>
}

// cleanupExpiredTimestamps 清理过期的时间戳
func (rl *RateLimiter) cleanupExpiredTimestamps() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        rl.mu.Lock()
                        now := time.Now()
                        keysToDelete := []string{}
                        for key, timestamps := range rl.store </span><span class="cov0" title="0">{
                                var valid []time.Time
                                for _, ts := range timestamps </span><span class="cov0" title="0">{
                                        if now.Sub(ts) &lt; rl.window </span><span class="cov0" title="0">{
                                                valid = append(valid, ts)
                                        }</span>
                                }

                                <span class="cov0" title="0">if len(valid) == 0 </span><span class="cov0" title="0">{
                                        keysToDelete = append(keysToDelete, key)
                                }</span> else<span class="cov0" title="0"> {
                                        rl.store[key] = valid
                                }</span>
                        }
                        <span class="cov0" title="0">for _, key := range keysToDelete </span><span class="cov0" title="0">{
                                delete(rl.store, key)
                        }</span>
                        <span class="cov0" title="0">rl.mu.Unlock()</span>

                case &lt;-rl.ctx.Done():<span class="cov0" title="0">
                        return</span>
                }
        }
}

// RateLimitMiddleware 速率限制中间件
func RateLimitMiddleware(limiter *RateLimiter) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // 获取客户端 IP
                clientIP := c.ClientIP()

                // 检查是否允许请求
                if !limiter.IsAllowed(clientIP) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "too many requests",
                                "code":  "RATE_LIMIT_EXCEEDED",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}

// PerEndpointRateLimiter 每个端点的速率限制器
type PerEndpointRateLimiter struct {
        limiters map[string]*RateLimiter
        mu       sync.RWMutex
}

// NewPerEndpointRateLimiter 创建每个端点的速率限制器
func NewPerEndpointRateLimiter() *PerEndpointRateLimiter <span class="cov0" title="0">{
        return &amp;PerEndpointRateLimiter{
                limiters: make(map[string]*RateLimiter),
        }
}</span>

// AddEndpoint 添加端点限制
func (p *PerEndpointRateLimiter) AddEndpoint(endpoint string, limit int, window time.Duration) <span class="cov0" title="0">{
        p.mu.Lock()
        defer p.mu.Unlock()
        p.limiters[endpoint] = NewRateLimiter(limit, window)
}</span>

// Middleware 返回中间件
func (p *PerEndpointRateLimiter) Middleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                p.mu.RLock()
                limiter, exists := p.limiters[c.Request.URL.Path]
                p.mu.RUnlock()

                if !exists </span><span class="cov0" title="0">{
                        // 使用默认限制（5 请求/分钟）
                        limiter = NewRateLimiter(5, 1*time.Minute)
                }</span>

                <span class="cov0" title="0">clientIP := c.ClientIP()
                key := fmt.Sprintf("%s:%s", c.Request.URL.Path, clientIP)

                if !limiter.IsAllowed(key) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusTooManyRequests, gin.H{
                                "error": "too many requests",
                                "code":  "RATE_LIMIT_EXCEEDED",
                        })
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// internal/migration/migrations/001_create_users_table.go
package migrations

import (
        "database/sql"
        "fmt"

        "monera-digital/internal/migration"
)

// CreateUsersTable migration
type CreateUsersTable struct{}

func (m *CreateUsersTable) Version() string <span class="cov0" title="0">{
        return "001"
}</span>

func (m *CreateUsersTable) Description() string <span class="cov0" title="0">{
        return "Create users table"
}</span>

func (m *CreateUsersTable) Up(db *sql.DB) error <span class="cov0" title="0">{
        query := `
        CREATE TABLE IF NOT EXISTS users (
                id SERIAL PRIMARY KEY,
                email VARCHAR(255) UNIQUE NOT NULL,
                password VARCHAR(255) NOT NULL,
                two_factor_secret VARCHAR(255),
                two_factor_enabled BOOLEAN DEFAULT FALSE,
                two_factor_backup_codes TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        `

        _, err := db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create users table: %w", err)
        }</span>

        // Create index on email
        <span class="cov0" title="0">indexQuery := `CREATE INDEX IF NOT EXISTS idx_users_email ON users(email)`
        _, err = db.Exec(indexQuery)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create email index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *CreateUsersTable) Down(db *sql.DB) error <span class="cov0" title="0">{
        query := `DROP TABLE IF EXISTS users`
        _, err := db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop users table: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CreateUsersTable implements Migration interface
var _ migration.Migration = (*CreateUsersTable)(nil)
</pre>
		
		<pre class="file" id="file26" style="display: none">// internal/migration/migrations/002_create_lending_positions_table.go
package migrations

import (
        "database/sql"
        "fmt"

        "monera-digital/internal/migration"
)

// CreateLendingPositionsTable migration
type CreateLendingPositionsTable struct{}

func (m *CreateLendingPositionsTable) Version() string <span class="cov0" title="0">{
        return "002"
}</span>

func (m *CreateLendingPositionsTable) Description() string <span class="cov0" title="0">{
        return "Create lending positions table"
}</span>

func (m *CreateLendingPositionsTable) Up(db *sql.DB) error <span class="cov0" title="0">{
        query := `
        CREATE TABLE IF NOT EXISTS lending_positions (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                asset VARCHAR(50) NOT NULL,
                amount DECIMAL(20, 8) NOT NULL,
                duration_days INTEGER NOT NULL,
                apy DECIMAL(5, 2) NOT NULL,
                status VARCHAR(50) DEFAULT 'active',
                accrued_yield DECIMAL(20, 8) DEFAULT 0,
                start_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                end_date TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        `

        _, err := db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create lending_positions table: %w", err)
        }</span>

        // Create indexes
        <span class="cov0" title="0">indexes := []string{
                `CREATE INDEX IF NOT EXISTS idx_lending_positions_user_id ON lending_positions(user_id)`,
                `CREATE INDEX IF NOT EXISTS idx_lending_positions_status ON lending_positions(status)`,
                `CREATE INDEX IF NOT EXISTS idx_lending_positions_asset ON lending_positions(asset)`,
        }

        for _, indexQuery := range indexes </span><span class="cov0" title="0">{
                _, err := db.Exec(indexQuery)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create index: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (m *CreateLendingPositionsTable) Down(db *sql.DB) error <span class="cov0" title="0">{
        query := `DROP TABLE IF EXISTS lending_positions`
        _, err := db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop lending_positions table: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ensure CreateLendingPositionsTable implements Migration interface
var _ migration.Migration = (*CreateLendingPositionsTable)(nil)
</pre>
		
		<pre class="file" id="file27" style="display: none">// internal/migration/migrations/003_create_withdrawal_tables.go
package migrations

import (
        "database/sql"
        "fmt"

        "monera-digital/internal/migration"
)

// CreateWithdrawalTables migration
type CreateWithdrawalTables struct{}

func (m *CreateWithdrawalTables) Version() string <span class="cov0" title="0">{
        return "003"
}</span>

func (m *CreateWithdrawalTables) Description() string <span class="cov0" title="0">{
        return "Create withdrawal related tables"
}</span>

func (m *CreateWithdrawalTables) Up(db *sql.DB) error <span class="cov0" title="0">{
        // 1. Create account table (if not exists)
        // This mirrors the 'accounts' table in Drizzle schema but we call it 'account' per PRD SQL.
        // We'll use IF NOT EXISTS to be safe.
        accountQuery := `
        CREATE TABLE IF NOT EXISTS account (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                type VARCHAR(32) NOT NULL, -- 'WEALTH', 'FUND'
                currency VARCHAR(32) NOT NULL,
                balance DECIMAL(32, 16) DEFAULT 0 NOT NULL,
                frozen_balance DECIMAL(32, 16) DEFAULT 0 NOT NULL,
                version BIGINT DEFAULT 1 NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX IF NOT EXISTS idx_account_user_id ON account(user_id);
        CREATE INDEX IF NOT EXISTS idx_account_frozen_balance ON account(user_id, frozen_balance);
        `
        if _, err := db.Exec(accountQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create account table: %w", err)
        }</span>

        // 2. Create withdrawal_address_whitelist
        <span class="cov0" title="0">whitelistQuery := `
        CREATE TABLE IF NOT EXISTS withdrawal_address_whitelist (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                address_alias VARCHAR(255) NOT NULL,
                chain_type VARCHAR(32) NOT NULL,
                wallet_address VARCHAR(255) NOT NULL,
                verified BOOLEAN DEFAULT FALSE,
                verified_at TIMESTAMP,
                verification_method VARCHAR(32),
                is_deleted BOOLEAN DEFAULT FALSE,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(user_id, wallet_address)
        );
        CREATE INDEX IF NOT EXISTS idx_whitelist_user_id ON withdrawal_address_whitelist(user_id);
        `
        if _, err := db.Exec(whitelistQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create withdrawal_address_whitelist table: %w", err)
        }</span>

        // 3. Create withdrawal_request
        <span class="cov0" title="0">requestQuery := `
        CREATE TABLE IF NOT EXISTS withdrawal_request (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                request_id VARCHAR(64) NOT NULL UNIQUE,
                status VARCHAR(32) DEFAULT 'PROCESSING',
                error_code VARCHAR(64),
                error_message TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX IF NOT EXISTS idx_request_request_id ON withdrawal_request(request_id);
        `
        if _, err := db.Exec(requestQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create withdrawal_request table: %w", err)
        }</span>

        // 4. Create withdrawal_order
        <span class="cov0" title="0">orderQuery := `
        CREATE TABLE IF NOT EXISTS withdrawal_order (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                amount DECIMAL(32, 16) NOT NULL,
                network_fee DECIMAL(32, 16),
                platform_fee DECIMAL(32, 16),
                actual_amount DECIMAL(32, 16),
                chain_type VARCHAR(32) NOT NULL,
                coin_type VARCHAR(32) NOT NULL,
                to_address VARCHAR(255) NOT NULL,
                safeheron_order_id VARCHAR(64),
                transaction_hash VARCHAR(255),
                status VARCHAR(32) DEFAULT 'PENDING',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                sent_at TIMESTAMP,
                confirmed_at TIMESTAMP,
                completed_at TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX IF NOT EXISTS idx_order_user_id ON withdrawal_order(user_id);
        CREATE INDEX IF NOT EXISTS idx_order_status ON withdrawal_order(status);
        `
        if _, err := db.Exec(orderQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create withdrawal_order table: %w", err)
        }</span>

        // 5. Create withdrawal_verification
        <span class="cov0" title="0">verificationQuery := `
        CREATE TABLE IF NOT EXISTS withdrawal_verification (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                withdrawal_order_id INTEGER NOT NULL, -- references withdrawal_order(id), but simplistic here
                verification_method VARCHAR(32) NOT NULL,
                verification_code VARCHAR(255),
                attempts INTEGER DEFAULT 0,
                max_attempts INTEGER DEFAULT 3,
                verified BOOLEAN DEFAULT FALSE,
                verified_at TIMESTAMP,
                expires_at TIMESTAMP,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX IF NOT EXISTS idx_verification_user_id ON withdrawal_verification(user_id);
        `
        if _, err := db.Exec(verificationQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create withdrawal_verification table: %w", err)
        }</span>

        // 6. Create withdrawal_freeze_log
        <span class="cov0" title="0">logQuery := `
        CREATE TABLE IF NOT EXISTS withdrawal_freeze_log (
                id SERIAL PRIMARY KEY,
                user_id INTEGER NOT NULL REFERENCES users(id),
                order_id INTEGER NOT NULL,
                amount DECIMAL(32, 16) NOT NULL,
                frozen_at TIMESTAMP,
                released_at TIMESTAMP,
                reason VARCHAR(64),
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );
        CREATE INDEX IF NOT EXISTS idx_log_user_id ON withdrawal_freeze_log(user_id);
        `
        if _, err := db.Exec(logQuery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create withdrawal_freeze_log table: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *CreateWithdrawalTables) Down(db *sql.DB) error <span class="cov0" title="0">{
        queries := []string{
                `DROP TABLE IF EXISTS withdrawal_freeze_log`,
                `DROP TABLE IF EXISTS withdrawal_verification`,
                `DROP TABLE IF EXISTS withdrawal_order`,
                `DROP TABLE IF EXISTS withdrawal_request`,
                `DROP TABLE IF EXISTS withdrawal_address_whitelist`,
                // We do NOT drop 'account' table as it might have been created by other migrations or we don't want to lose data.
                // Or we could drop the column frozen_balance if we wanted to be precise.
                `ALTER TABLE account DROP COLUMN IF EXISTS frozen_balance`,
        }

        for _, query := range queries </span><span class="cov0" title="0">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to execute down migration: %w", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Ensure CreateWithdrawalTables implements Migration interface
var _ migration.Migration = (*CreateWithdrawalTables)(nil)
</pre>
		
		<pre class="file" id="file28" style="display: none">package migrations

import (
        "database/sql"
        "fmt"

        "monera-digital/internal/migration"
)

// AddTwoFactorColumnsMigration adds 2FA columns to the users table
type AddTwoFactorColumnsMigration struct{}

func (m *AddTwoFactorColumnsMigration) Version() string <span class="cov8" title="1">{
        return "004"
}</span>

func (m *AddTwoFactorColumnsMigration) Description() string <span class="cov8" title="1">{
        return "Add two factor columns to users table"
}</span>

func (m *AddTwoFactorColumnsMigration) Up(db *sql.DB) error <span class="cov0" title="0">{
        // Add two_factor_secret column
        _, err := db.Exec(`
                ALTER TABLE users
                ADD COLUMN IF NOT EXISTS two_factor_secret TEXT
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add two_factor_secret column: %w", err)
        }</span>

        // Add two_factor_backup_codes column
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE users
                ADD COLUMN IF NOT EXISTS two_factor_backup_codes TEXT
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add two_factor_backup_codes column: %w", err)
        }</span>

        // Add two_factor_enabled column (default false)
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE users
                ADD COLUMN IF NOT EXISTS two_factor_enabled BOOLEAN DEFAULT FALSE
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add two_factor_enabled column: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *AddTwoFactorColumnsMigration) Down(db *sql.DB) error <span class="cov0" title="0">{
        // Remove columns in reverse order
        _, err := db.Exec(`
                ALTER TABLE users
                DROP COLUMN IF EXISTS two_factor_enabled
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop two_factor_enabled column: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE users
                DROP COLUMN IF EXISTS two_factor_backup_codes
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop two_factor_backup_codes column: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE users
                DROP COLUMN IF EXISTS two_factor_secret
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop two_factor_secret column: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Ensure AddTwoFactorColumnsMigration implements Migration interface
var _ migration.Migration = (*AddTwoFactorColumnsMigration)(nil)
</pre>
		
		<pre class="file" id="file29" style="display: none">package migrations

import (
        "database/sql"
        "fmt"

        "monera-digital/internal/migration"
)

// AddTwoFactorTimestampMigration adds timestamp field for replay attack prevention
type AddTwoFactorTimestampMigration struct{}

func (m *AddTwoFactorTimestampMigration) Version() string <span class="cov8" title="1">{
        return "005"
}</span>

func (m *AddTwoFactorTimestampMigration) Description() string <span class="cov8" title="1">{
        return "Add two factor timestamp column for replay attack prevention"
}</span>

func (m *AddTwoFactorTimestampMigration) Up(db *sql.DB) error <span class="cov0" title="0">{
        // Add two_factor_last_used_at column for replay attack prevention
        _, err := db.Exec(`
                ALTER TABLE users
                ADD COLUMN IF NOT EXISTS two_factor_last_used_at BIGINT DEFAULT 0
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add two_factor_last_used_at column: %w", err)
        }</span>

        // Create index for performance (optional but recommended)
        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE INDEX IF NOT EXISTS idx_users_two_factor_last_used_at
                ON users(two_factor_last_used_at)
                WHERE two_factor_enabled = TRUE
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create two_factor_last_used_at index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *AddTwoFactorTimestampMigration) Down(db *sql.DB) error <span class="cov0" title="0">{
        // Drop index first
        _, err := db.Exec(`
                DROP INDEX IF EXISTS idx_users_two_factor_last_used_at
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop two_factor_last_used_at index: %w", err)
        }</span>

        // Remove column
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE users
                DROP COLUMN IF EXISTS two_factor_last_used_at
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop two_factor_last_used_at column: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Ensure AddTwoFactorTimestampMigration implements Migration interface
var _ migration.Migration = (*AddTwoFactorTimestampMigration)(nil)
</pre>
		
		<pre class="file" id="file30" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "monera-digital/internal/migration"
)

// UpdateWalletRequestsTable migration
type UpdateWalletRequestsTable struct{}

func (m *UpdateWalletRequestsTable) Version() string <span class="cov0" title="0">{
        return "007"
}</span>

func (m *UpdateWalletRequestsTable) Description() string <span class="cov0" title="0">{
        return "Update wallet requests table with product code and currency"
}</span>

func (m *UpdateWalletRequestsTable) Up(db *sql.DB) error <span class="cov0" title="0">{
        // Add product_code and currency columns if they don't exist
        _, err := db.Exec(`
                ALTER TABLE wallet_creation_requests 
                ADD COLUMN IF NOT EXISTS product_code VARCHAR(50) DEFAULT '',
                ADD COLUMN IF NOT EXISTS currency VARCHAR(20) DEFAULT '';
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add columns: %w", err)
        }</span>

        // Create unique index for user_id, product_code, and currency
        // We first need to handle potential duplicates if there's existing data
        // For simplicity in this migration, we'll assume clean data or manual cleanup required if duplicates exist
        // In production, we might want to do a cleanup step first

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE UNIQUE INDEX IF NOT EXISTS idx_wallet_requests_user_product_currency 
                ON wallet_creation_requests (user_id, product_code, currency)
                WHERE status = 'SUCCESS';
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create unique index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *UpdateWalletRequestsTable) Down(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`
                DROP INDEX IF EXISTS idx_wallet_requests_user_product_currency;
                ALTER TABLE wallet_creation_requests 
                DROP COLUMN IF EXISTS product_code,
                DROP COLUMN IF EXISTS currency;
        `)
        return err
}</span>

// Ensure UpdateWalletRequestsTable implements Migration interface
var _ migration.Migration = (*UpdateWalletRequestsTable)(nil)
</pre>
		
		<pre class="file" id="file31" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "monera-digital/internal/migration"
)

// CreateUserWalletsTable migration
type CreateUserWalletsTable struct{}

func (m *CreateUserWalletsTable) Version() string <span class="cov0" title="0">{
        return "008"
}</span>

func (m *CreateUserWalletsTable) Description() string <span class="cov0" title="0">{
        return "Create user_wallets table for storing individual wallet addresses"
}</span>

func (m *CreateUserWalletsTable) Up(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`
                CREATE TABLE IF NOT EXISTS user_wallets (
                        id SERIAL PRIMARY KEY,
                        user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
                        request_id VARCHAR(36) NOT NULL REFERENCES wallet_creation_requests(request_id) ON DELETE SET NULL,
                        wallet_id VARCHAR(100) NOT NULL,
                        currency VARCHAR(50) NOT NULL,
                        address VARCHAR(255) NOT NULL,
                        address_type VARCHAR(50),
                        derive_path VARCHAR(100),
                        is_primary BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
                )
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user_wallets table: %w", err)
        }</span>

        // Create indexes for common queries
        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE INDEX IF NOT EXISTS idx_user_wallets_user_id ON user_wallets(user_id)
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create user_id index: %w", err)
        }</span>

        <span class="cov0" title="0">_, err = db.Exec(`
                CREATE UNIQUE INDEX IF NOT EXISTS idx_user_wallets_user_currency ON user_wallets(user_id, currency)
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create unique index: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *CreateUserWalletsTable) Down(db *sql.DB) error <span class="cov0" title="0">{
        _, err := db.Exec(`
                DROP INDEX IF EXISTS idx_user_wallets_user_currency;
                DROP INDEX IF EXISTS idx_user_wallets_user_id;
                DROP TABLE IF EXISTS user_wallets;
        `)
        return err
}</span>

// Ensure CreateUserWalletsTable implements Migration interface
var _ migration.Migration = (*CreateUserWalletsTable)(nil)
</pre>
		
		<pre class="file" id="file32" style="display: none">package migrations

import (
        "database/sql"
        "fmt"
        "monera-digital/internal/migration"
)

// AddUserWalletStatusField migration
type AddUserWalletStatusField struct{}

func (m *AddUserWalletStatusField) Version() string <span class="cov0" title="0">{
        return "009"
}</span>

func (m *AddUserWalletStatusField) Description() string <span class="cov0" title="0">{
        return "Add status field to user_wallets and remove NOT NULL from request_id"
}</span>

func (m *AddUserWalletStatusField) Up(db *sql.DB) error <span class="cov0" title="0">{
        // Remove NOT NULL from request_id
        _, err := db.Exec(`
                ALTER TABLE user_wallets ALTER COLUMN request_id DROP NOT NULL
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove NOT NULL from request_id: %w", err)
        }</span>

        // Add status column with default NORMAL
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE user_wallets ADD COLUMN IF NOT EXISTS status VARCHAR(20) NOT NULL DEFAULT 'NORMAL'
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add status column: %w", err)
        }</span>

        // Add check constraint for valid status values
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE user_wallets DROP CONSTRAINT IF EXISTS ck_user_wallets_status;
                ALTER TABLE user_wallets ADD CONSTRAINT ck_user_wallets_status
                CHECK (status IN ('NORMAL', 'FROZEN', 'CANCELLED'))
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to add status check constraint: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m *AddUserWalletStatusField) Down(db *sql.DB) error <span class="cov0" title="0">{
        // Remove check constraint
        _, err := db.Exec(`
                ALTER TABLE user_wallets DROP CONSTRAINT IF EXISTS ck_user_wallets_status
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop check constraint: %w", err)
        }</span>

        // Remove status column
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE user_wallets DROP COLUMN IF EXISTS status
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to drop status column: %w", err)
        }</span>

        // Restore NOT NULL on request_id
        <span class="cov0" title="0">_, err = db.Exec(`
                ALTER TABLE user_wallets ALTER COLUMN request_id SET NOT NULL
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to restore NOT NULL on request_id: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Ensure AddUserWalletStatusField implements Migration interface
var _ migration.Migration = (*AddUserWalletStatusField)(nil)
</pre>
		
		<pre class="file" id="file33" style="display: none">// internal/migration/migrator.go
package migration

import (
        "database/sql"
        "fmt"
        "log"
        "time"
)

// Migrator manages database migrations
type Migrator struct {
        db         *sql.DB
        migrations []Migration
}

// NewMigrator creates a new migrator instance
func NewMigrator(db *sql.DB) *Migrator <span class="cov0" title="0">{
        return &amp;Migrator{
                db:         db,
                migrations: []Migration{},
        }
}</span>

// Register registers a migration
func (m *Migrator) Register(migration Migration) <span class="cov0" title="0">{
        m.migrations = append(m.migrations, migration)
}</span>

// Init initializes the migration tracking table
func (m *Migrator) Init() error <span class="cov0" title="0">{
        query := `
        CREATE TABLE IF NOT EXISTS migrations (
                id SERIAL PRIMARY KEY,
                version VARCHAR(50) UNIQUE NOT NULL,
                name VARCHAR(255) NOT NULL,
                executed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        `

        _, err := m.db.Exec(query)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Migrations table initialized")
        return nil</span>
}

// GetAppliedMigrations returns all applied migrations
func (m *Migrator) GetAppliedMigrations() ([]MigrationRecord, error) <span class="cov0" title="0">{
        query := `SELECT id, version, name, executed_at FROM migrations ORDER BY executed_at ASC`

        rows, err := m.db.Query(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query migrations: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var records []MigrationRecord
        for rows.Next() </span><span class="cov0" title="0">{
                var record MigrationRecord
                if err := rows.Scan(&amp;record.ID, &amp;record.Version, &amp;record.Name, &amp;record.ExecutedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan migration record: %w", err)
                }</span>
                <span class="cov0" title="0">records = append(records, record)</span>
        }

        <span class="cov0" title="0">return records, rows.Err()</span>
}

// GetStatus returns the status of all migrations
func (m *Migrator) GetStatus() ([]MigrationStatus, error) <span class="cov0" title="0">{
        applied, err := m.GetAppliedMigrations()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">appliedMap := make(map[string]bool)
        appliedTimeMap := make(map[string]time.Time)

        for _, record := range applied </span><span class="cov0" title="0">{
                appliedMap[record.Version] = true
                appliedTimeMap[record.Version] = record.ExecutedAt
        }</span>

        <span class="cov0" title="0">var statuses []MigrationStatus
        for _, migration := range m.migrations </span><span class="cov0" title="0">{
                version := migration.Version()
                status := "pending"
                var executedAt *time.Time

                if appliedMap[version] </span><span class="cov0" title="0">{
                        status = "applied"
                        t := appliedTimeMap[version]
                        executedAt = &amp;t
                }</span>

                <span class="cov0" title="0">statuses = append(statuses, MigrationStatus{
                        Version:    version,
                        Name:       migration.Description(),
                        Status:     status,
                        ExecutedAt: executedAt,
                })</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}

// Migrate runs all pending migrations
func (m *Migrator) Migrate() error <span class="cov0" title="0">{
        if err := m.Init(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">applied, err := m.GetAppliedMigrations()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">appliedMap := make(map[string]bool)
        for _, record := range applied </span><span class="cov0" title="0">{
                appliedMap[record.Version] = true
        }</span>

        <span class="cov0" title="0">for _, migration := range m.migrations </span><span class="cov0" title="0">{
                version := migration.Version()

                if appliedMap[version] </span><span class="cov0" title="0">{
                        log.Printf("Migration %s already applied, skipping\n", version)
                        continue</span>
                }

                <span class="cov0" title="0">log.Printf("Running migration %s: %s\n", version, migration.Description())

                if err := migration.Up(m.db); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("migration %s failed: %w", version, err)
                }</span>

                // Record the migration
                <span class="cov0" title="0">query := `INSERT INTO migrations (version, name) VALUES ($1, $2)`
                _, err := m.db.Exec(query, version, migration.Description())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to record migration %s: %w", version, err)
                }</span>

                <span class="cov0" title="0">log.Printf("Migration %s completed successfully\n", version)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Rollback reverts the last migration
func (m *Migrator) Rollback() error <span class="cov0" title="0">{
        applied, err := m.GetAppliedMigrations()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(applied) == 0 </span><span class="cov0" title="0">{
                log.Println("No migrations to rollback")
                return nil
        }</span>

        <span class="cov0" title="0">lastRecord := applied[len(applied)-1]

        // Find the migration
        var migration Migration
        for _, m := range m.migrations </span><span class="cov0" title="0">{
                if m.Version() == lastRecord.Version </span><span class="cov0" title="0">{
                        migration = m
                        break</span>
                }
        }

        <span class="cov0" title="0">if migration == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("migration %s not found", lastRecord.Version)
        }</span>

        <span class="cov0" title="0">log.Printf("Rolling back migration %s\n", lastRecord.Version)

        if err := migration.Down(m.db); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("rollback of migration %s failed: %w", lastRecord.Version, err)
        }</span>

        // Remove the migration record
        <span class="cov0" title="0">query := `DELETE FROM migrations WHERE version = $1`
        _, err = m.db.Exec(query, lastRecord.Version)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove migration record: %w", err)
        }</span>

        <span class="cov0" title="0">log.Printf("Migration %s rolled back successfully\n", lastRecord.Version)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// internal/models/token.go
package models

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
)

// TokenPair 令牌对（访问令牌 + 刷新令牌）
type TokenPair struct {
        AccessToken  string    `json:"accessToken"`
        RefreshToken string    `json:"refreshToken"`
        TokenType    string    `json:"tokenType"`
        ExpiresIn    int       `json:"expiresIn"`
        ExpiresAt    time.Time `json:"expiresAt"`
}

// TokenClaims JWT 令牌声明
type TokenClaims struct {
        UserID    int    `json:"userId"`
        Email     string `json:"email"`
        TokenType string `json:"tokenType"` // "access" 或 "refresh"
        ExpiresAt int64  `json:"exp"`
        IssuedAt  int64  `json:"iat"`
}

// Implement jwt.Claims interface
func (tc *TokenClaims) GetAudience() (jwt.ClaimStrings, error) <span class="cov0" title="0">{
        return jwt.ClaimStrings{}, nil
}</span>

func (tc *TokenClaims) GetExpirationTime() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        if tc.ExpiresAt == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">t := jwt.NewNumericDate(time.Unix(tc.ExpiresAt, 0))
        return t, nil</span>
}

func (tc *TokenClaims) GetIssuedAt() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        if tc.IssuedAt == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">t := jwt.NewNumericDate(time.Unix(tc.IssuedAt, 0))
        return t, nil</span>
}

func (tc *TokenClaims) GetIssuer() (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (tc *TokenClaims) GetNotBefore() (*jwt.NumericDate, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (tc *TokenClaims) GetSubject() (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

// RefreshTokenRequest 刷新令牌请求
type RefreshTokenRequest struct {
        RefreshToken string `json:"refreshToken" binding:"required"`
}

// RefreshTokenResponse 刷新令牌响应
type RefreshTokenResponse struct {
        AccessToken string    `json:"accessToken"`
        ExpiresIn   int       `json:"expiresIn"`
        ExpiresAt   time.Time `json:"expiresAt"`
}

// LogoutRequest 登出请求
type LogoutRequest struct {
        Token string `json:"token" binding:"required"`
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// internal/monitoring/health_check.go
package monitoring

import (
        "context"
        "database/sql"
        "net/http"
        "time"

        "github.com/gin-gonic/gin"
        "monera-digital/internal/cache"
)

// HealthCheckService provides health check functionality
type HealthCheckService struct {
        db      *sql.DB
        cache   cache.CacheService
        metrics *Metrics
}

// NewHealthCheckService creates a new health check service
func NewHealthCheckService(db *sql.DB, cache cache.CacheService, metrics *Metrics) *HealthCheckService <span class="cov0" title="0">{
        return &amp;HealthCheckService{
                db:      db,
                cache:   cache,
                metrics: metrics,
        }
}</span>

// HealthStatus represents the health status of the system
type HealthStatus struct {
        Status     string                     `json:"status"`
        Timestamp  time.Time                  `json:"timestamp"`
        Uptime     float64                    `json:"uptime_seconds"`
        Components map[string]ComponentStatus `json:"components"`
        Metrics    map[string]interface{}     `json:"metrics"`
}

// ComponentStatus represents the status of a system component
type ComponentStatus struct {
        Status  string `json:"status"`
        Message string `json:"message,omitempty"`
}

// Check performs a health check on all components
func (hcs *HealthCheckService) Check() *HealthStatus <span class="cov0" title="0">{
        status := &amp;HealthStatus{
                Status:     "healthy",
                Timestamp:  time.Now(),
                Components: make(map[string]ComponentStatus),
                Metrics:    hcs.metrics.GetSnapshot(),
        }

        // Check database
        if err := hcs.checkDatabase(); err != nil </span><span class="cov0" title="0">{
                status.Components["database"] = ComponentStatus{
                        Status:  "unhealthy",
                        Message: err.Error(),
                }
                status.Status = "degraded"
        }</span> else<span class="cov0" title="0"> {
                status.Components["database"] = ComponentStatus{Status: "healthy"}
        }</span>

        // Check cache
        <span class="cov0" title="0">if err := hcs.checkCache(); err != nil </span><span class="cov0" title="0">{
                status.Components["cache"] = ComponentStatus{
                        Status:  "unhealthy",
                        Message: err.Error(),
                }
                status.Status = "degraded"
        }</span> else<span class="cov0" title="0"> {
                status.Components["cache"] = ComponentStatus{Status: "healthy"}
        }</span>

        // Calculate uptime
        <span class="cov0" title="0">status.Uptime = time.Since(hcs.metrics.StartTime).Seconds()

        return status</span>
}

// checkDatabase checks database connectivity
func (hcs *HealthCheckService) checkDatabase() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := hcs.db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// checkCache checks cache connectivity
func (hcs *HealthCheckService) checkCache() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        // Try to set and get a test key
        testKey := "health_check_test"
        testValue := "ok"

        if err := hcs.cache.Set(ctx, testKey, testValue, 10*time.Second); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">val, err := hcs.cache.Get(ctx, testKey)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if val != testValue </span><span class="cov0" title="0">{
                return ErrCacheValueMismatch
        }</span>

        // Clean up
        <span class="cov0" title="0">_ = hcs.cache.Delete(ctx, testKey)

        return nil</span>
}

// HealthCheckHandler returns a Gin handler for health checks
func (hcs *HealthCheckService) HealthCheckHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                status := hcs.Check()

                statusCode := http.StatusOK
                if status.Status == "unhealthy" </span><span class="cov0" title="0">{
                        statusCode = http.StatusServiceUnavailable
                }</span> else<span class="cov0" title="0"> if status.Status == "degraded" </span><span class="cov0" title="0">{
                        statusCode = http.StatusOK // Still return 200 but indicate degraded status
                }</span>

                <span class="cov0" title="0">c.JSON(statusCode, status)</span>
        }
}

// MetricsHandler returns a Gin handler for metrics
func (hcs *HealthCheckService) MetricsHandler() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(http.StatusOK, hcs.metrics.GetSnapshot())
        }</span>
}

// CacheError represents a cache-related error
type CacheError struct {
        Operation string
        Key       string
        Message   string
}

func (e *CacheError) Error() string <span class="cov0" title="0">{
        return e.Message
}</span>

// Custom errors
var (
        ErrCacheValueMismatch = &amp;CacheError{
                Operation: "health_check",
                Key:       "health_check_test",
                Message:   "cache value mismatch",
        }
)
</pre>
		
		<pre class="file" id="file36" style="display: none">// internal/monitoring/metrics.go
package monitoring

import (
        "sync"
        "time"
)

// Metrics represents application metrics
type Metrics struct {
        mu sync.RWMutex

        // Request metrics
        TotalRequests      int64
        SuccessfulRequests int64
        FailedRequests     int64
        TotalResponseTime  time.Duration

        // Error metrics
        ErrorCount map[string]int64

        // Cache metrics
        CacheHits   int64
        CacheMisses int64

        // Database metrics
        DBQueryCount    int64
        DBQueryDuration time.Duration

        // Timestamp
        StartTime time.Time
        LastReset time.Time
}

// NewMetrics creates a new metrics instance
func NewMetrics() *Metrics <span class="cov0" title="0">{
        return &amp;Metrics{
                ErrorCount: make(map[string]int64),
                StartTime:  time.Now(),
                LastReset:  time.Now(),
        }
}</span>

// RecordRequest records a request
func (m *Metrics) RecordRequest(duration time.Duration, success bool) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.TotalRequests++
        m.TotalResponseTime += duration

        if success </span><span class="cov0" title="0">{
                m.SuccessfulRequests++
        }</span> else<span class="cov0" title="0"> {
                m.FailedRequests++
        }</span>
}

// RecordError records an error
func (m *Metrics) RecordError(errorType string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.ErrorCount[errorType]++
}</span>

// RecordCacheHit records a cache hit
func (m *Metrics) RecordCacheHit() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.CacheHits++
}</span>

// RecordCacheMiss records a cache miss
func (m *Metrics) RecordCacheMiss() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.CacheMisses++
}</span>

// RecordDBQuery records a database query
func (m *Metrics) RecordDBQuery(duration time.Duration) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.DBQueryCount++
        m.DBQueryDuration += duration
}</span>

// GetAverageResponseTime returns average response time
func (m *Metrics) GetAverageResponseTime() time.Duration <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.TotalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return m.TotalResponseTime / time.Duration(m.TotalRequests)</span>
}

// GetSuccessRate returns success rate percentage
func (m *Metrics) GetSuccessRate() float64 <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.TotalRequests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(m.SuccessfulRequests) / float64(m.TotalRequests) * 100</span>
}

// GetCacheHitRate returns cache hit rate percentage
func (m *Metrics) GetCacheHitRate() float64 <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        totalCacheOps := m.CacheHits + m.CacheMisses
        if totalCacheOps == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return float64(m.CacheHits) / float64(totalCacheOps) * 100</span>
}

// GetAverageDBQueryTime returns average database query time
func (m *Metrics) GetAverageDBQueryTime() time.Duration <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if m.DBQueryCount == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">return m.DBQueryDuration / time.Duration(m.DBQueryCount)</span>
}

// GetSnapshot returns a snapshot of current metrics
func (m *Metrics) GetSnapshot() map[string]interface{} <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return map[string]interface{}{
                "total_requests":       m.TotalRequests,
                "successful_requests":  m.SuccessfulRequests,
                "failed_requests":      m.FailedRequests,
                "success_rate":         m.GetSuccessRate(),
                "avg_response_time_ms": m.GetAverageResponseTime().Milliseconds(),
                "cache_hits":           m.CacheHits,
                "cache_misses":         m.CacheMisses,
                "cache_hit_rate":       m.GetCacheHitRate(),
                "db_query_count":       m.DBQueryCount,
                "avg_db_query_time_ms": m.GetAverageDBQueryTime().Milliseconds(),
                "error_count":          m.ErrorCount,
                "uptime_seconds":       time.Since(m.StartTime).Seconds(),
        }
}</span>

// Reset resets all metrics
func (m *Metrics) Reset() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.TotalRequests = 0
        m.SuccessfulRequests = 0
        m.FailedRequests = 0
        m.TotalResponseTime = 0
        m.ErrorCount = make(map[string]int64)
        m.CacheHits = 0
        m.CacheMisses = 0
        m.DBQueryCount = 0
        m.DBQueryDuration = 0
        m.LastReset = time.Now()
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">// internal/monitoring/monitoring_middleware.go
package monitoring

import (
        "time"

        "github.com/gin-gonic/gin"
)

// MonitoringMiddleware creates a middleware that records request metrics
func MonitoringMiddleware(metrics *Metrics) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                start := time.Now()

                // Process request
                c.Next()

                // Record metrics
                duration := time.Since(start)
                statusCode := c.Writer.Status()
                success := statusCode &gt;= 200 &amp;&amp; statusCode &lt; 400

                metrics.RecordRequest(duration, success)

                // Record errors
                if !success </span><span class="cov0" title="0">{
                        errorType := c.GetString("error_type")
                        if errorType == "" </span><span class="cov0" title="0">{
                                errorType = "unknown_error"
                        }</span>
                        <span class="cov0" title="0">metrics.RecordError(errorType)</span>
                }
        }
}

// AlertThreshold represents an alert threshold
type AlertThreshold struct {
        Name          string
        Condition     func(*Metrics) bool
        Message       string
        SeverityLevel string // "info", "warning", "critical"
}

// AlertManager manages system alerts
type AlertManager struct {
        metrics    *Metrics
        thresholds []*AlertThreshold
        alerts     []Alert
}

// Alert represents a triggered alert
type Alert struct {
        Timestamp     time.Time
        Message       string
        SeverityLevel string
        Resolved      bool
}

// NewAlertManager creates a new alert manager
func NewAlertManager(metrics *Metrics) *AlertManager <span class="cov0" title="0">{
        return &amp;AlertManager{
                metrics:    metrics,
                thresholds: make([]*AlertThreshold, 0),
                alerts:     make([]Alert, 0),
        }
}</span>

// AddThreshold adds an alert threshold
func (am *AlertManager) AddThreshold(threshold *AlertThreshold) <span class="cov0" title="0">{
        am.thresholds = append(am.thresholds, threshold)
}</span>

// Check checks all thresholds and triggers alerts if needed
func (am *AlertManager) Check() []Alert <span class="cov0" title="0">{
        var triggeredAlerts []Alert

        for _, threshold := range am.thresholds </span><span class="cov0" title="0">{
                if threshold.Condition(am.metrics) </span><span class="cov0" title="0">{
                        alert := Alert{
                                Timestamp:     time.Now(),
                                Message:       threshold.Message,
                                SeverityLevel: threshold.SeverityLevel,
                                Resolved:      false,
                        }
                        triggeredAlerts = append(triggeredAlerts, alert)
                        am.alerts = append(am.alerts, alert)
                }</span>
        }

        <span class="cov0" title="0">return triggeredAlerts</span>
}

// GetActiveAlerts returns all active (unresolved) alerts
func (am *AlertManager) GetActiveAlerts() []Alert <span class="cov0" title="0">{
        var activeAlerts []Alert
        for _, alert := range am.alerts </span><span class="cov0" title="0">{
                if !alert.Resolved </span><span class="cov0" title="0">{
                        activeAlerts = append(activeAlerts, alert)
                }</span>
        }
        <span class="cov0" title="0">return activeAlerts</span>
}

// ResolveAlert marks an alert as resolved
func (am *AlertManager) ResolveAlert(index int) <span class="cov0" title="0">{
        if index &gt;= 0 &amp;&amp; index &lt; len(am.alerts) </span><span class="cov0" title="0">{
                am.alerts[index].Resolved = true
        }</span>
}

// ClearResolvedAlerts removes resolved alerts
func (am *AlertManager) ClearResolvedAlerts() <span class="cov0" title="0">{
        var activeAlerts []Alert
        for _, alert := range am.alerts </span><span class="cov0" title="0">{
                if !alert.Resolved </span><span class="cov0" title="0">{
                        activeAlerts = append(activeAlerts, alert)
                }</span>
        }
        <span class="cov0" title="0">am.alerts = activeAlerts</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// internal/performance/benchmark.go
package performance

import (
        "fmt"
        "time"
)

// BenchmarkResult represents the result of a benchmark
type BenchmarkResult struct {
        Name            string
        Iterations      int
        TotalDuration   time.Duration
        AvgDuration     time.Duration
        MinDuration     time.Duration
        MaxDuration     time.Duration
        OpsPerSecond    float64
        MemoryAllocated uint64
}

// Benchmark runs a function multiple times and measures performance
type Benchmark struct {
        name       string
        iterations int
        fn         func() error
        results    []time.Duration
}

// NewBenchmark creates a new benchmark
func NewBenchmark(name string, iterations int, fn func() error) *Benchmark <span class="cov0" title="0">{
        return &amp;Benchmark{
                name:       name,
                iterations: iterations,
                fn:         fn,
                results:    make([]time.Duration, 0, iterations),
        }
}</span>

// Run executes the benchmark
func (b *Benchmark) Run() (*BenchmarkResult, error) <span class="cov0" title="0">{
        for i := 0; i &lt; b.iterations; i++ </span><span class="cov0" title="0">{
                start := time.Now()
                if err := b.fn(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("benchmark iteration %d failed: %w", i, err)
                }</span>
                <span class="cov0" title="0">duration := time.Since(start)
                b.results = append(b.results, duration)</span>
        }

        <span class="cov0" title="0">return b.calculateResults(), nil</span>
}

// calculateResults calculates benchmark statistics
func (b *Benchmark) calculateResults() *BenchmarkResult <span class="cov0" title="0">{
        if len(b.results) == 0 </span><span class="cov0" title="0">{
                return &amp;BenchmarkResult{Name: b.name}
        }</span>

        <span class="cov0" title="0">var totalDuration time.Duration
        minDuration := b.results[0]
        maxDuration := b.results[0]

        for _, duration := range b.results </span><span class="cov0" title="0">{
                totalDuration += duration
                if duration &lt; minDuration </span><span class="cov0" title="0">{
                        minDuration = duration
                }</span>
                <span class="cov0" title="0">if duration &gt; maxDuration </span><span class="cov0" title="0">{
                        maxDuration = duration
                }</span>
        }

        <span class="cov0" title="0">avgDuration := totalDuration / time.Duration(len(b.results))
        opsPerSecond := float64(len(b.results)) / totalDuration.Seconds()

        return &amp;BenchmarkResult{
                Name:          b.name,
                Iterations:    len(b.results),
                TotalDuration: totalDuration,
                AvgDuration:   avgDuration,
                MinDuration:   minDuration,
                MaxDuration:   maxDuration,
                OpsPerSecond:  opsPerSecond,
        }</span>
}

// String returns a formatted string representation of the result
func (r *BenchmarkResult) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "Benchmark: %s\n"+
                        "  Iterations: %d\n"+
                        "  Total Duration: %v\n"+
                        "  Avg Duration: %v\n"+
                        "  Min Duration: %v\n"+
                        "  Max Duration: %v\n"+
                        "  Ops/sec: %.2f\n",
                r.Name,
                r.Iterations,
                r.TotalDuration,
                r.AvgDuration,
                r.MinDuration,
                r.MaxDuration,
                r.OpsPerSecond,
        )
}</span>

// BenchmarkSuite runs multiple benchmarks
type BenchmarkSuite struct {
        name       string
        benchmarks []*Benchmark
        results    []*BenchmarkResult
}

// NewBenchmarkSuite creates a new benchmark suite
func NewBenchmarkSuite(name string) *BenchmarkSuite <span class="cov0" title="0">{
        return &amp;BenchmarkSuite{
                name:       name,
                benchmarks: make([]*Benchmark, 0),
                results:    make([]*BenchmarkResult, 0),
        }
}</span>

// Add adds a benchmark to the suite
func (bs *BenchmarkSuite) Add(benchmark *Benchmark) <span class="cov0" title="0">{
        bs.benchmarks = append(bs.benchmarks, benchmark)
}</span>

// Run executes all benchmarks in the suite
func (bs *BenchmarkSuite) Run() error <span class="cov0" title="0">{
        fmt.Printf("Running Benchmark Suite: %s\n", bs.name)
        fmt.Println(string(make([]byte, 50)))

        for _, benchmark := range bs.benchmarks </span><span class="cov0" title="0">{
                result, err := benchmark.Run()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">bs.results = append(bs.results, result)
                fmt.Println(result.String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Summary returns a summary of all benchmark results
func (bs *BenchmarkSuite) Summary() string <span class="cov0" title="0">{
        summary := fmt.Sprintf("Benchmark Suite Summary: %s\n", bs.name)
        summary += fmt.Sprintf("Total Benchmarks: %d\n", len(bs.results))

        var totalOpsPerSecond float64
        for _, result := range bs.results </span><span class="cov0" title="0">{
                totalOpsPerSecond += result.OpsPerSecond
        }</span>

        <span class="cov0" title="0">summary += fmt.Sprintf("Total Ops/sec: %.2f\n", totalOpsPerSecond)
        return summary</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type AccountRepositoryV1 struct {
        db *sql.DB
}

func NewAccountRepositoryV1(db *sql.DB) repository.Account <span class="cov8" title="1">{
        return &amp;AccountRepositoryV1{db: db}
}</span>

func (r *AccountRepositoryV1) GetByUserIDAndType(ctx context.Context, userID int, accountType string) (*models.Account, error) <span class="cov0" title="0">{
        var account models.Account
        err := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, type, currency, balance, frozen_balance, version, created_at, updated_at
                 FROM account WHERE user_id = $1 AND type = $2`,
                userID, accountType).Scan(
                &amp;account.ID, &amp;account.UserID, &amp;account.Type, &amp;account.Currency,
                &amp;account.Balance, &amp;account.FrozenBalance, &amp;account.Version,
                &amp;account.CreatedAt, &amp;account.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;account, nil</span>
}

func (r *AccountRepositoryV1) Create(ctx context.Context, account *models.Account) error <span class="cov0" title="0">{
        err := r.db.QueryRowContext(ctx,
                `INSERT INTO account (user_id, type, currency, balance, frozen_balance, version, created_at, updated_at)
                 VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                 RETURNING id`,
                account.UserID, account.Type, account.Currency, account.Balance, account.FrozenBalance,
                1, time.Now(), time.Now()).Scan(&amp;account.ID)
        return err
}</span>

func (r *AccountRepositoryV1) UpdateFrozenBalance(ctx context.Context, userID int, amount float64) error <span class="cov8" title="1">{
        // Add to frozen (and check balance if needed, but logic usually in Service.
        // PRD says: UPDATE account SET frozen_balance = frozen_balance + amount ...
        result, err := r.db.ExecContext(ctx,
                `UPDATE account
                 SET frozen_balance = frozen_balance + $1, version = version + 1, updated_at = $3
                 WHERE user_id = $2`,
                amount, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if rows == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (r *AccountRepositoryV1) ReleaseFrozenBalance(ctx context.Context, userID int, amount float64) error <span class="cov0" title="0">{
        result, err := r.db.ExecContext(ctx,
                `UPDATE account
                 SET frozen_balance = frozen_balance - $1, version = version + 1, updated_at = $3
                 WHERE user_id = $2 AND frozen_balance &gt;= $1`,
                amount, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                // Could mean not found OR frozen balance insufficient (should not happen if logic correct)
                return repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *AccountRepositoryV1) DeductBalance(ctx context.Context, userID int, amount float64) error <span class="cov0" title="0">{
        // Deduct from BOTH balance and frozen (since it was frozen first).
        // PRD 5.3: frozen_balance = frozen_balance - amount, balance = balance - amount
        result, err := r.db.ExecContext(ctx,
                `UPDATE account
                 SET frozen_balance = frozen_balance - $1, balance = balance - $1, version = version + 1, updated_at = $3
                 WHERE user_id = $2 AND frozen_balance &gt;= $1`,
                amount, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "time"

        "github.com/lib/pq"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type AddressRepository struct {
        db *sql.DB
}

func NewAddressRepository(db *sql.DB) repository.Address <span class="cov0" title="0">{
        return &amp;AddressRepository{db: db}
}</span>

func (r *AddressRepository) CreateAddress(ctx context.Context, address *models.WithdrawalAddress) (*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        err := r.db.QueryRowContext(ctx,
                `INSERT INTO withdrawal_address_whitelist (
                        user_id, address_alias, chain_type, wallet_address, verified,
                        verified_at, verification_method, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id`,
                address.UserID, address.AddressAlias, address.ChainType, address.WalletAddress,
                address.Verified, address.VerifiedAt, address.VerificationMethod,
                time.Now(), time.Now(),
        ).Scan(&amp;address.ID)
        if err != nil </span><span class="cov0" title="0">{
                if pqErr, ok := err.(*pq.Error); ok &amp;&amp; pqErr.Code == "23505" </span><span class="cov0" title="0">{
                        return nil, repository.ErrAlreadyExists
                }</span>
                // Fallback legacy check just in case
                <span class="cov0" title="0">if err.Error() == "pq: duplicate key value violates unique constraint \"withdrawal_address_whitelist_user_id_wallet_address_key\"" </span><span class="cov0" title="0">{
                        return nil, repository.ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return address, nil</span>
}

func (r *AddressRepository) GetAddressesByUserID(ctx context.Context, userID int) ([]*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, user_id, address_alias, chain_type, wallet_address, verified,
                        verified_at, verification_method, is_deleted, created_at, updated_at
                FROM withdrawal_address_whitelist
                WHERE user_id = $1 AND is_deleted = FALSE`,
                userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        addresses := make([]*models.WithdrawalAddress, 0, 10)
        for rows.Next() </span><span class="cov0" title="0">{
                var addr models.WithdrawalAddress
                if err := rows.Scan(
                        &amp;addr.ID, &amp;addr.UserID, &amp;addr.AddressAlias, &amp;addr.ChainType, &amp;addr.WalletAddress,
                        &amp;addr.Verified, &amp;addr.VerifiedAt, &amp;addr.VerificationMethod, &amp;addr.IsDeleted,
                        &amp;addr.CreatedAt, &amp;addr.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">addresses = append(addresses, &amp;addr)</span>
        }
        <span class="cov0" title="0">return addresses, nil</span>
}

func (r *AddressRepository) GetAddressByID(ctx context.Context, id int) (*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        var addr models.WithdrawalAddress
        err := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, address_alias, chain_type, wallet_address, verified,
                        verified_at, verification_method, is_deleted, created_at, updated_at
                FROM withdrawal_address_whitelist WHERE id = $1 AND is_deleted = FALSE`,
                id).Scan(
                &amp;addr.ID, &amp;addr.UserID, &amp;addr.AddressAlias, &amp;addr.ChainType, &amp;addr.WalletAddress,
                &amp;addr.Verified, &amp;addr.VerifiedAt, &amp;addr.VerificationMethod, &amp;addr.IsDeleted,
                &amp;addr.CreatedAt, &amp;addr.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;addr, nil</span>
}

func (r *AddressRepository) UpdateAddress(ctx context.Context, address *models.WithdrawalAddress) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `UPDATE withdrawal_address_whitelist SET
                        address_alias = $1, verified = $2, verified_at = $3,
                        verification_method = $4, updated_at = $5
                WHERE id = $6`,
                address.AddressAlias, address.Verified, address.VerifiedAt,
                address.VerificationMethod, time.Now(), address.ID)
        return err
}</span>

func (r *AddressRepository) DeleteAddress(ctx context.Context, id int) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `UPDATE withdrawal_address_whitelist SET is_deleted = TRUE, updated_at = $1 WHERE id = $2`,
                time.Now(), id)
        return err
}</span>

func (r *AddressRepository) GetByAddressAndChain(ctx context.Context, address, chain string) (*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        // This might be used to check duplicates globally? Or per user?
        // The interface doesn't specify UserID. Assuming per user if called from service, but repository is generic.
        // Actually, the unique constraint is (user_id, wallet_address).
        // If checking if an address is blacklisted or something?
        // PRD says: "Check if address is in whitelist".
        // Maybe GetByUserIDAndAddress?
        // The interface signature I defined earlier was `GetByAddressAndChain(ctx, address, chain)`.
        // This seems insufficient without UserID.
        // I'll leave it as finding ANY record for now, or assume it's used for something else.
        // But wait, the PRD says "Check if address is in whitelist" usually implies checking if the USER has it.
        // I'll implement it as finding the first match (maybe not useful) or update interface.
        // Better: Update interface to include UserID.

        // For now, simple implementation:
        var addr models.WithdrawalAddress
        err := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, address_alias, chain_type, wallet_address, verified,
                        verified_at, verification_method, is_deleted, created_at, updated_at
                FROM withdrawal_address_whitelist WHERE wallet_address = $1 AND chain_type = $2 AND is_deleted = FALSE LIMIT 1`,
                address, chain).Scan(
                &amp;addr.ID, &amp;addr.UserID, &amp;addr.AddressAlias, &amp;addr.ChainType, &amp;addr.WalletAddress,
                &amp;addr.Verified, &amp;addr.VerifiedAt, &amp;addr.VerificationMethod, &amp;addr.IsDeleted,
                &amp;addr.CreatedAt, &amp;addr.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;addr, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type DepositRepository struct {
        db *sql.DB
}

func NewDepositRepository(db *sql.DB) repository.Deposit <span class="cov0" title="0">{
        return &amp;DepositRepository{db: db}
}</span>

func (r *DepositRepository) Create(ctx context.Context, deposit *models.Deposit) error <span class="cov0" title="0">{
        query := `
                INSERT INTO deposits (user_id, tx_hash, amount, asset, chain, status, from_address, to_address, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id`

        err := r.db.QueryRowContext(ctx, query,
                deposit.UserID, deposit.TxHash, deposit.Amount, deposit.Asset, deposit.Chain,
                deposit.Status, deposit.FromAddress, deposit.ToAddress, time.Now(),
        ).Scan(&amp;deposit.ID)
        return err
}</span>

func (r *DepositRepository) GetByTxHash(ctx context.Context, txHash string) (*models.Deposit, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, tx_hash, amount, asset, chain, status, from_address, to_address, created_at, confirmed_at
                FROM deposits WHERE tx_hash = $1`

        var d models.Deposit

        err := r.db.QueryRowContext(ctx, query, txHash).Scan(
                &amp;d.ID, &amp;d.UserID, &amp;d.TxHash, &amp;d.Amount, &amp;d.Asset, &amp;d.Chain, &amp;d.Status,
                &amp;d.FromAddress, &amp;d.ToAddress, &amp;d.CreatedAt, &amp;d.ConfirmedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;d, nil</span>
}

func (r *DepositRepository) GetByUserID(ctx context.Context, userID int, limit, offset int) ([]*models.Deposit, int64, error) <span class="cov0" title="0">{
        // Count
        var total int64
        err := r.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM deposits WHERE user_id = $1", userID).Scan(&amp;total)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">query := `
                SELECT id, user_id, tx_hash, amount, asset, chain, status, from_address, to_address, created_at, confirmed_at
                FROM deposits WHERE user_id = $1
                ORDER BY created_at DESC
                LIMIT $2 OFFSET $3`

        rows, err := r.db.QueryContext(ctx, query, userID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        deposits := make([]*models.Deposit, 0, limit)
        for rows.Next() </span><span class="cov0" title="0">{
                var d models.Deposit
                if err := rows.Scan(&amp;d.ID, &amp;d.UserID, &amp;d.TxHash, &amp;d.Amount, &amp;d.Asset, &amp;d.Chain, &amp;d.Status, &amp;d.FromAddress, &amp;d.ToAddress, &amp;d.CreatedAt, &amp;d.ConfirmedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>
                <span class="cov0" title="0">deposits = append(deposits, &amp;d)</span>
        }
        <span class="cov0" title="0">return deposits, total, nil</span>
}

func (r *DepositRepository) UpdateStatus(ctx context.Context, id int, status string, confirmedAt string) error <span class="cov0" title="0">{
        var confirmedTime interface{} = nil
        if confirmedAt != "" </span><span class="cov0" title="0">{
                t, err := time.Parse(time.RFC3339, confirmedAt)
                if err == nil </span><span class="cov0" title="0">{
                        confirmedTime = t
                }</span> else<span class="cov0" title="0"> {
                        confirmedTime = time.Now() // Fallback
                }</span>
        }
        <span class="cov0" title="0">query := `UPDATE deposits SET status = $1, confirmed_at = $2 WHERE id = $3`
        _, err := r.db.ExecContext(ctx, query, status, confirmedTime, id)
        return err</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// internal/repository/postgres/user.go
package postgres

import (
        "context"
        "database/sql"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

// UserRepository PostgreSQL 用户仓储实现
type UserRepository struct {
        db *sql.DB
}

// NewUserRepository 创建用户仓储
func NewUserRepository(db *sql.DB) repository.User <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

// GetByEmail 根据邮箱获取用户
func (r *UserRepository) GetByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User

        err := r.db.QueryRowContext(
                ctx,
                `SELECT id, email, password, two_factor_enabled, two_factor_secret,
                        two_factor_backup_codes, created_at
                 FROM users WHERE email = $1`,
                email,
        ).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.TwoFactorEnabled,
                &amp;user.TwoFactorSecret,
                &amp;user.TwoFactorBackupCodes,
                &amp;user.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetByID 根据ID获取用户
func (r *UserRepository) GetByID(ctx context.Context, id int) (*models.User, error) <span class="cov0" title="0">{
        var user models.User

        err := r.db.QueryRowContext(
                ctx,
                `SELECT id, email, password, two_factor_enabled, two_factor_secret,
                        two_factor_backup_codes, created_at
                 FROM users WHERE id = $1`,
                id,
        ).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.TwoFactorEnabled,
                &amp;user.TwoFactorSecret,
                &amp;user.TwoFactorBackupCodes,
                &amp;user.CreatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// Create 创建用户
func (r *UserRepository) Create(ctx context.Context, email, passwordHash string) (*models.User, error) <span class="cov0" title="0">{
        var user models.User

        err := r.db.QueryRowContext(
                ctx,
                `INSERT INTO users (email, password, created_at, updated_at)
                 VALUES ($1, $2, $3, $4)
                 RETURNING id, email, password, two_factor_enabled, two_factor_secret,
                           two_factor_backup_codes, created_at`,
                email,
                passwordHash,
                time.Now(),
                time.Now(),
        ).Scan(
                &amp;user.ID,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.TwoFactorEnabled,
                &amp;user.TwoFactorSecret,
                &amp;user.TwoFactorBackupCodes,
                &amp;user.CreatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                // 检查唯一性约束
                if err.Error() == "pq: duplicate key value violates unique constraint \"users_email_key\"" </span><span class="cov0" title="0">{
                        return nil, repository.ErrAlreadyExists
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return &amp;user, nil</span>
}

// Update 更新用户
func (r *UserRepository) Update(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        result, err := r.db.ExecContext(
                ctx,
                `UPDATE users
                 SET email = $1, password = $2, two_factor_enabled = $3,
                     two_factor_secret = $4, two_factor_backup_codes = $5, updated_at = $6
                 WHERE id = $7`,
                user.Email,
                user.Password,
                user.TwoFactorEnabled,
                user.TwoFactorSecret,
                user.TwoFactorBackupCodes,
                time.Now(),
                user.ID,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete 删除用户
func (r *UserRepository) Delete(ctx context.Context, id int) error <span class="cov0" title="0">{
        result, err := r.db.ExecContext(
                ctx,
                `DELETE FROM users WHERE id = $1`,
                id,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rowsAffected, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if rowsAffected == 0 </span><span class="cov0" title="0">{
                return repository.ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type WalletRepository struct {
        db *sql.DB
}

func NewWalletRepository(db *sql.DB) repository.Wallet <span class="cov0" title="0">{
        return &amp;WalletRepository{db: db}
}</span>

func (r *WalletRepository) CreateRequest(ctx context.Context, req *models.WalletCreationRequest) error <span class="cov0" title="0">{
        query := `
                INSERT INTO wallet_creation_requests (request_id, user_id, product_code, currency, status, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING id`
        return r.db.QueryRowContext(ctx, query, req.RequestID, req.UserID, req.ProductCode, req.Currency, req.Status, time.Now(), time.Now()).Scan(&amp;req.ID)
}</span>

func (r *WalletRepository) GetRequestByUserID(ctx context.Context, userID int) (*models.WalletCreationRequest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, request_id, user_id, product_code, currency, status, wallet_id, address, addresses, error_message, created_at, updated_at
                FROM wallet_creation_requests WHERE user_id = $1 ORDER BY created_at DESC LIMIT 1`

        var w models.WalletCreationRequest
        err := r.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;w.ID, &amp;w.RequestID, &amp;w.UserID, &amp;w.ProductCode, &amp;w.Currency, &amp;w.Status, &amp;w.WalletID, &amp;w.Address, &amp;w.Addresses, &amp;w.ErrorMessage, &amp;w.CreatedAt, &amp;w.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

func (r *WalletRepository) UpdateRequest(ctx context.Context, req *models.WalletCreationRequest) error <span class="cov0" title="0">{
        query := `
                UPDATE wallet_creation_requests
                SET status = $1, wallet_id = $2, address = $3, addresses = $4, error_message = $5, updated_at = $6
                WHERE id = $7`
        _, err := r.db.ExecContext(ctx, query,
                req.Status, req.WalletID, req.Address, req.Addresses, req.ErrorMessage, time.Now(), req.ID,
        )
        return err
}</span>

func (r *WalletRepository) GetWalletByUserProductCurrency(ctx context.Context, userID int, productCode, currency string) (*models.WalletCreationRequest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, request_id, user_id, product_code, currency, status, wallet_id, address, addresses, error_message, created_at, updated_at
                FROM wallet_creation_requests 
                WHERE user_id = $1 AND product_code = $2 AND currency = $3 
                ORDER BY created_at DESC LIMIT 1`

        var w models.WalletCreationRequest
        err := r.db.QueryRowContext(ctx, query, userID, productCode, currency).Scan(
                &amp;w.ID, &amp;w.RequestID, &amp;w.UserID, &amp;w.ProductCode, &amp;w.Currency, &amp;w.Status, &amp;w.WalletID, &amp;w.Address, &amp;w.Addresses, &amp;w.ErrorMessage, &amp;w.CreatedAt, &amp;w.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

func (r *WalletRepository) GetActiveWalletByUserID(ctx context.Context, userID int) (*models.WalletCreationRequest, error) <span class="cov0" title="0">{
        query := `
                SELECT id, request_id, user_id, product_code, currency, status, wallet_id, address, addresses, error_message, created_at, updated_at
                FROM wallet_creation_requests WHERE user_id = $1 AND status = 'SUCCESS' ORDER BY created_at DESC LIMIT 1`

        var w models.WalletCreationRequest
        err := r.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;w.ID, &amp;w.RequestID, &amp;w.UserID, &amp;w.ProductCode, &amp;w.Currency, &amp;w.Status, &amp;w.WalletID, &amp;w.Address, &amp;w.Addresses, &amp;w.ErrorMessage, &amp;w.CreatedAt, &amp;w.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

// CreateUserWallet inserts a new user wallet record
func (r *WalletRepository) CreateUserWallet(ctx context.Context, wallet *models.UserWallet) error <span class="cov0" title="0">{
        query := `
                INSERT INTO user_wallets (user_id, request_id, wallet_id, currency, address, address_type, derive_path, is_primary, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                RETURNING id`
        return r.db.QueryRowContext(ctx, query,
                wallet.UserID, wallet.RequestID, wallet.WalletID, wallet.Currency,
                wallet.Address, wallet.AddressType, wallet.DerivePath, wallet.IsPrimary,
                time.Now(), time.Now(),
        ).Scan(&amp;wallet.ID)
}</span>

// GetUserWalletsByUserID retrieves all wallets for a user
func (r *WalletRepository) GetUserWalletsByUserID(ctx context.Context, userID int) ([]*models.UserWallet, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, request_id, wallet_id, currency, address, address_type, derive_path, status, is_primary, created_at, updated_at
                FROM user_wallets WHERE user_id = $1 ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var wallets []*models.UserWallet
        for rows.Next() </span><span class="cov0" title="0">{
                var w models.UserWallet
                err := rows.Scan(
                        &amp;w.ID, &amp;w.UserID, &amp;w.RequestID, &amp;w.WalletID, &amp;w.Currency,
                        &amp;w.Address, &amp;w.AddressType, &amp;w.DerivePath, &amp;w.Status, &amp;w.IsPrimary,
                        &amp;w.CreatedAt, &amp;w.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">wallets = append(wallets, &amp;w)</span>
        }
        <span class="cov0" title="0">return wallets, rows.Err()</span>
}

// GetUserWalletByCurrency retrieves a specific wallet by currency
func (r *WalletRepository) GetUserWalletByCurrency(ctx context.Context, userID int, currency string) (*models.UserWallet, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, request_id, wallet_id, currency, address, address_type, derive_path, status, is_primary, created_at, updated_at
                FROM user_wallets WHERE user_id = $1 AND currency = $2 LIMIT 1`

        var w models.UserWallet
        err := r.db.QueryRowContext(ctx, query, userID, currency).Scan(
                &amp;w.ID, &amp;w.UserID, &amp;w.RequestID, &amp;w.WalletID, &amp;w.Currency,
                &amp;w.Address, &amp;w.AddressType, &amp;w.DerivePath, &amp;w.Status, &amp;w.IsPrimary,
                &amp;w.CreatedAt, &amp;w.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

// UpdateUserWalletStatus updates the status of a user wallet
func (r *WalletRepository) UpdateUserWalletStatus(ctx context.Context, id int, status models.UserWalletStatus) error <span class="cov0" title="0">{
        query := `UPDATE user_wallets SET status = $1, updated_at = NOW() WHERE id = $2`
        result, err := r.db.ExecContext(ctx, query, status, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("user wallet not found: %d", id)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetActiveUserWallet retrieves the first active (non-cancelled) wallet for a user from user_wallets
func (r *WalletRepository) GetActiveUserWallet(ctx context.Context, userID int) (*models.UserWallet, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, request_id, wallet_id, currency, address, address_type, derive_path, status, is_primary, created_at, updated_at
                FROM user_wallets WHERE user_id = $1 AND status != 'CANCELLED' ORDER BY created_at DESC LIMIT 1`

        var w models.UserWallet
        err := r.db.QueryRowContext(ctx, query, userID).Scan(
                &amp;w.ID, &amp;w.UserID, &amp;w.RequestID, &amp;w.WalletID, &amp;w.Currency,
                &amp;w.Address, &amp;w.AddressType, &amp;w.DerivePath, &amp;w.Status, &amp;w.IsPrimary,
                &amp;w.CreatedAt, &amp;w.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;w, nil</span>
}

// AddUserWalletAddress adds a new address for the user, checking if it already exists.
// Returns the existing wallet if found, or creates a new one.
func (r *WalletRepository) AddUserWalletAddress(ctx context.Context, wallet *models.UserWallet) (*models.UserWallet, error) <span class="cov0" title="0">{
        // Check if wallet already exists for this user and currency
        existing, err := r.GetUserWalletByCurrency(ctx, wallet.UserID, wallet.Currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return existing, nil
        }</span>

        // Create new wallet address
        <span class="cov0" title="0">wallet.Status = models.UserWalletStatusNormal
        wallet.IsPrimary = false
        err = r.CreateUserWallet(ctx, wallet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return wallet, nil</span>
}

// GetUserWalletByUserAndCurrency gets wallet by user and currency
func (r *WalletRepository) GetUserWalletByUserAndCurrency(ctx context.Context, userID int, currency string) (*models.UserWallet, error) <span class="cov0" title="0">{
        return r.GetUserWalletByCurrency(ctx, userID, currency)
}</span>

// Ensure WalletRepository implements repository.Wallet
var _ repository.Wallet = (*WalletRepository)(nil)
</pre>
		
		<pre class="file" id="file44" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "fmt"
        "monera-digital/internal/repository"
        "strconv"
        "time"
)

type WealthRepository struct {
        db *sql.DB
}

func NewWealthRepository(db *sql.DB) *WealthRepository <span class="cov0" title="0">{
        return &amp;WealthRepository{db: db}
}</span>

func (r *WealthRepository) GetActiveProducts(ctx context.Context) ([]*repository.WealthProductModel, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, currency, apy, duration, min_amount, max_amount,
                       total_quota, sold_quota, status, auto_renew_allowed, created_at, updated_at
                FROM wealth_product
                WHERE status = 1
                ORDER BY created_at DESC
        `
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var products []*repository.WealthProductModel
        for rows.Next() </span><span class="cov0" title="0">{
                var p repository.WealthProductModel
                err := rows.Scan(
                        &amp;p.ID, &amp;p.Title, &amp;p.Currency, &amp;p.APY, &amp;p.Duration,
                        &amp;p.MinAmount, &amp;p.MaxAmount, &amp;p.TotalQuota, &amp;p.SoldQuota,
                        &amp;p.Status, &amp;p.AutoRenewAllowed, &amp;p.CreatedAt, &amp;p.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">products = append(products, &amp;p)</span>
        }
        <span class="cov0" title="0">return products, rows.Err()</span>
}

func (r *WealthRepository) GetProductByID(ctx context.Context, id int64) (*repository.WealthProductModel, error) <span class="cov0" title="0">{
        query := `
                SELECT id, title, currency, apy, duration, min_amount, max_amount,
                       total_quota, sold_quota, status, auto_renew_allowed, created_at, updated_at
                FROM wealth_product
                WHERE id = $1
        `
        var p repository.WealthProductModel
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;p.ID, &amp;p.Title, &amp;p.Currency, &amp;p.APY, &amp;p.Duration,
                &amp;p.MinAmount, &amp;p.MaxAmount, &amp;p.TotalQuota, &amp;p.SoldQuota,
                &amp;p.Status, &amp;p.AutoRenewAllowed, &amp;p.CreatedAt, &amp;p.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;p, nil</span>
}

func (r *WealthRepository) CreateOrder(ctx context.Context, order *repository.WealthOrderModel) error <span class="cov0" title="0">{
        query := `
                INSERT INTO wealth_order (user_id, product_id, product_title, currency, amount,
                        principal_redeemed, interest_expected, interest_paid, interest_accrued,
                        start_date, end_date, auto_renew, status, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, '0', '0', '0', '0', $6, $7, $8, 1, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                RETURNING id
        `
        err := r.db.QueryRowContext(ctx, query,
                order.UserID, order.ProductID, order.ProductTitle, order.Currency, order.Amount,
                order.StartDate, order.EndDate, order.AutoRenew,
        ).Scan(&amp;order.ID)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[DEBUG] CreateOrder - error: %v\n", err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

func (r *WealthRepository) GetOrdersByUserID(ctx context.Context, userID int64) ([]*repository.WealthOrderModel, error) <span class="cov0" title="0">{
        query := `
                SELECT o.id, o.user_id, o.product_id, p.title as product_title, p.currency,
                        o.amount,
                        o.interest_expected, o.interest_paid, o.interest_accrued, o.start_date, o.end_date,
                        o.auto_renew, o.status, o.renewed_from_order_id, o.renewed_to_order_id,
                        o.redemption_amount, o.redemption_type, o.redeemed_at, o.created_at, o.updated_at
                FROM wealth_order o
                JOIN wealth_product p ON o.product_id = p.id
                WHERE o.user_id = $1
                ORDER BY o.created_at DESC
        `
        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*repository.WealthOrderModel
        for rows.Next() </span><span class="cov0" title="0">{
                var o repository.WealthOrderModel
                var redemptionAmount, redeemedAt sql.NullString
                var redemptionType sql.NullString
                err := rows.Scan(
                        &amp;o.ID, &amp;o.UserID, &amp;o.ProductID, &amp;o.ProductTitle, &amp;o.Currency,
                        &amp;o.Amount,
                        &amp;o.InterestExpected, &amp;o.InterestPaid, &amp;o.InterestAccrued,
                        &amp;o.StartDate, &amp;o.EndDate, &amp;o.AutoRenew, &amp;o.Status,
                        &amp;o.RenewedFromOrderID, &amp;o.RenewedToOrderID,
                        &amp;redemptionAmount, &amp;redemptionType, &amp;redeemedAt,
                        &amp;o.CreatedAt, &amp;o.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">o.RedemptionAmount = redemptionAmount.String
                o.RedemptionType = redemptionType
                o.RedeemedAt = redeemedAt.String
                orders = append(orders, &amp;o)</span>
        }
        <span class="cov0" title="0">return orders, rows.Err()</span>
}

func (r *WealthRepository) GetOrderByID(ctx context.Context, id int64) (*repository.WealthOrderModel, error) <span class="cov0" title="0">{
        query := `
                SELECT o.id, o.user_id, o.product_id, p.title as product_title, p.currency, o.amount,
                        o.interest_expected, o.interest_paid, o.interest_accrued, o.start_date, o.end_date,
                        o.auto_renew, o.status, o.renewed_from_order_id, o.renewed_to_order_id,
                        o.redemption_amount, o.redemption_type, o.redeemed_at, o.created_at, o.updated_at
                FROM wealth_order o
                JOIN wealth_product p ON o.product_id = p.id
                WHERE o.id = $1
        `
        var o repository.WealthOrderModel
        var redemptionAmount, redeemedAt sql.NullString
        var redemptionType sql.NullString
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;o.ID, &amp;o.UserID, &amp;o.ProductID, &amp;o.ProductTitle, &amp;o.Currency, &amp;o.Amount,
                &amp;o.InterestExpected, &amp;o.InterestPaid, &amp;o.InterestAccrued,
                &amp;o.StartDate, &amp;o.EndDate, &amp;o.AutoRenew, &amp;o.Status,
                &amp;o.RenewedFromOrderID, &amp;o.RenewedToOrderID,
                &amp;redemptionAmount, &amp;redemptionType, &amp;redeemedAt,
                &amp;o.CreatedAt, &amp;o.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">o.RedemptionAmount = redemptionAmount.String
        o.RedemptionType = redemptionType
        o.RedeemedAt = redeemedAt.String
        return &amp;o, nil</span>
}

func (r *WealthRepository) UpdateOrder(ctx context.Context, order *repository.WealthOrderModel) error <span class="cov0" title="0">{
        query := `
                UPDATE wealth_order SET
                        interest_paid = $1, interest_accrued = $2, status = $3,
                        redemption_amount = $4, redemption_type = $5, redeemed_at = $6,
                        updated_at = $7
                WHERE id = $8
        `
        _, err := r.db.ExecContext(ctx, query,
                order.InterestPaid, order.InterestAccrued, order.Status,
                order.RedemptionAmount, order.RedemptionType, order.RedeemedAt,
                order.UpdatedAt, order.ID,
        )
        return err
}</span>

func (r *WealthRepository) UpdateProductSoldQuota(ctx context.Context, id int64, amount string) error <span class="cov0" title="0">{
        query := `
                UPDATE wealth_product SET
                        sold_quota = CAST(CAST(sold_quota AS NUMERIC) + CAST($1 AS NUMERIC) AS TEXT),
                        updated_at = $2
                WHERE id = $3
        `
        _, err := r.db.ExecContext(ctx, query, amount, "now()", id)
        return err
}</span>

type AccountRepository struct {
        db *sql.DB
}

func NewAccountRepository(db *sql.DB) repository.AccountV2 <span class="cov0" title="0">{
        return &amp;AccountRepository{db: db}
}</span>

func (r *AccountRepository) GetAccountByUserIDAndCurrency(ctx context.Context, userID int64, currency string) (*repository.AccountModel, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, type, currency, balance, frozen_balance, version, created_at, updated_at
                FROM account
                WHERE user_id = $1 AND currency = $2
        `
        var a repository.AccountModel
        err := r.db.QueryRowContext(ctx, query, userID, currency).Scan(
                &amp;a.ID, &amp;a.UserID, &amp;a.Type, &amp;a.Currency,
                &amp;a.Balance, &amp;a.FrozenBalance, &amp;a.Version,
                &amp;a.CreatedAt, &amp;a.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("account not found for user %d and currency %s", userID, currency)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;a, nil</span>
}

func (r *AccountRepository) GetAccountsByUserID(ctx context.Context, userID int64) ([]*repository.AccountModel, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, type, currency, balance, frozen_balance, version, created_at, updated_at
                FROM account
                WHERE user_id = $1
                ORDER BY currency
        `
        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var accounts []*repository.AccountModel
        for rows.Next() </span><span class="cov0" title="0">{
                var a repository.AccountModel
                err := rows.Scan(
                        &amp;a.ID, &amp;a.UserID, &amp;a.Type, &amp;a.Currency,
                        &amp;a.Balance, &amp;a.FrozenBalance, &amp;a.Version,
                        &amp;a.CreatedAt, &amp;a.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">accounts = append(accounts, &amp;a)</span>
        }
        <span class="cov0" title="0">return accounts, rows.Err()</span>
}

func (r *AccountRepository) FreezeBalance(ctx context.Context, accountID int64, amount string) error <span class="cov0" title="0">{
        query := `
                UPDATE account SET
                        frozen_balance = frozen_balance + CAST($1 AS NUMERIC),
                        version = version + 1,
                        updated_at = NOW()
                WHERE id = $2
        `
        _, err := r.db.ExecContext(ctx, query, amount, accountID)
        return err
}</span>

func (r *AccountRepository) UnfreezeBalance(ctx context.Context, accountID int64, amount string) error <span class="cov0" title="0">{
        query := `
                UPDATE account SET
                        frozen_balance = frozen_balance - CAST($1 AS NUMERIC),
                        version = version + 1,
                        updated_at = NOW()
                WHERE id = $2
        `
        _, err := r.db.ExecContext(ctx, query, amount, accountID)
        return err
}</span>

func (r *AccountRepository) DeductBalance(ctx context.Context, accountID int64, amount string) error <span class="cov0" title="0">{
        query := `
                UPDATE account SET
                        balance = CAST(CAST(balance AS NUMERIC) - CAST($1 AS NUMERIC) AS TEXT),
                        version = version + 1,
                        updated_at = $2
                WHERE id = $3
        `
        _, err := r.db.ExecContext(ctx, query, amount, "now()", accountID)
        return err
}</span>

func (r *AccountRepository) AddBalance(ctx context.Context, accountID int64, amount string) error <span class="cov0" title="0">{
        query := `
                UPDATE account SET
                        balance = balance + CAST($1 AS NUMERIC),
                        version = version + 1,
                        updated_at = NOW()
                WHERE id = $2
        `
        _, err := r.db.ExecContext(ctx, query, amount, accountID)
        return err
}</span>

func (r *WealthRepository) GetActiveOrders(ctx context.Context) ([]*repository.WealthOrderModel, error) <span class="cov0" title="0">{
        query := `
                SELECT o.id, o.user_id, o.product_id, p.title as product_title, p.currency, o.amount,
                        o.interest_expected, o.interest_paid, o.interest_accrued, o.start_date, o.end_date,
                        o.auto_renew, o.status, o.renewed_from_order_id, o.renewed_to_order_id,
                        o.redemption_amount, o.redemption_type, o.redeemed_at, o.created_at, o.updated_at
                FROM wealth_order o
                JOIN wealth_product p ON o.product_id = p.id
                WHERE o.status = 1
                ORDER BY o.created_at DESC
        `
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*repository.WealthOrderModel
        for rows.Next() </span><span class="cov0" title="0">{
                var o repository.WealthOrderModel
                var redemptionAmount, redeemedAt sql.NullString
                var redemptionType sql.NullString
                err := rows.Scan(
                        &amp;o.ID, &amp;o.UserID, &amp;o.ProductID, &amp;o.ProductTitle, &amp;o.Currency, &amp;o.Amount,
                        &amp;o.InterestExpected, &amp;o.InterestPaid, &amp;o.InterestAccrued,
                        &amp;o.StartDate, &amp;o.EndDate, &amp;o.AutoRenew, &amp;o.Status,
                        &amp;o.RenewedFromOrderID, &amp;o.RenewedToOrderID,
                        &amp;redemptionAmount, &amp;redemptionType, &amp;redeemedAt,
                        &amp;o.CreatedAt, &amp;o.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">o.RedemptionAmount = redemptionAmount.String
                o.RedemptionType = redemptionType
                o.RedeemedAt = redeemedAt.String
                orders = append(orders, &amp;o)</span>
        }
        <span class="cov0" title="0">return orders, rows.Err()</span>
}

func (r *WealthRepository) GetExpiredOrders(ctx context.Context) ([]*repository.WealthOrderModel, error) <span class="cov0" title="0">{
        query := `
                SELECT o.id, o.user_id, o.product_id, p.title as product_title, p.currency, o.amount,
                        o.interest_expected, o.interest_paid, o.interest_accrued, o.start_date, o.end_date,
                        o.auto_renew, o.status, o.renewed_from_order_id, o.renewed_to_order_id,
                        o.redemption_amount, o.redemption_type, o.redeemed_at, o.created_at, o.updated_at
                FROM wealth_order o
                JOIN wealth_product p ON o.product_id = p.id
                WHERE o.status = 1 AND o.end_date &lt;= CURRENT_DATE
                ORDER BY o.created_at DESC
        `
        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var orders []*repository.WealthOrderModel
        for rows.Next() </span><span class="cov0" title="0">{
                var o repository.WealthOrderModel
                var redemptionAmount, redeemedAt sql.NullString
                var redemptionType sql.NullString
                err := rows.Scan(
                        &amp;o.ID, &amp;o.UserID, &amp;o.ProductID, &amp;o.ProductTitle, &amp;o.Currency, &amp;o.Amount,
                        &amp;o.InterestExpected, &amp;o.InterestPaid, &amp;o.InterestAccrued,
                        &amp;o.StartDate, &amp;o.EndDate, &amp;o.AutoRenew, &amp;o.Status,
                        &amp;o.RenewedFromOrderID, &amp;o.RenewedToOrderID,
                        &amp;redemptionAmount, &amp;redemptionType, &amp;redeemedAt,
                        &amp;o.CreatedAt, &amp;o.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">o.RedemptionAmount = redemptionAmount.String
                o.RedemptionType = redemptionType
                o.RedeemedAt = redeemedAt.String
                orders = append(orders, &amp;o)</span>
        }
        <span class="cov0" title="0">return orders, rows.Err()</span>
}

func (r *WealthRepository) AccrueInterest(ctx context.Context, orderID int64, amount string, date string) error <span class="cov0" title="0">{
        query := `
                UPDATE wealth_order SET
                        interest_accrued = CAST(CAST(interest_accrued AS NUMERIC) + CAST($1 AS NUMERIC) AS TEXT),
                        last_interest_date = $2,
                        updated_at = $3
                WHERE id = $4
        `
        _, err := r.db.ExecContext(ctx, query, amount, date, "now()", orderID)
        return err
}</span>

func (r *WealthRepository) SettleOrder(ctx context.Context, orderID int64, interestPaid string) error <span class="cov0" title="0">{
        query := `
                UPDATE wealth_order SET
                        interest_paid = CAST(CAST(interest_paid AS NUMERIC) + CAST($1 AS NUMERIC) AS TEXT),
                        interest_accrued = '0',
                        status = 3,
                        redeemed_at = $2,
                        updated_at = $3
                WHERE id = $4
        `
        _, err := r.db.ExecContext(ctx, query, interestPaid, "now()", "now()", orderID)
        return err
}</span>

func (r *WealthRepository) RenewOrder(ctx context.Context, order *repository.WealthOrderModel, product *repository.WealthProductModel) (*repository.WealthOrderModel, error) <span class="cov0" title="0">{
        now := time.Now()
        startDate := now.Format("2006-01-02")
        endDate := now.AddDate(0, 0, product.Duration).Format("2006-01-02")

        apy, _ := strconv.ParseFloat(product.APY, 64)
        amountFloat, _ := strconv.ParseFloat(order.Amount, 64)
        dailyInterest := amountFloat * (apy / 100) / 365
        interestExpected := strconv.FormatFloat(dailyInterest*float64(product.Duration), 'f', -1, 64)

        newOrder := &amp;repository.WealthOrderModel{
                UserID:             order.UserID,
                ProductID:          product.ID,
                ProductTitle:       product.Title,
                Currency:           product.Currency,
                Amount:             order.Amount,
                AutoRenew:          order.AutoRenew,
                Status:             1,
                StartDate:          startDate,
                EndDate:            endDate,
                PrincipalRedeemed:  "0",
                InterestExpected:   interestExpected,
                InterestPaid:       "0",
                InterestAccrued:    "0",
                LastInterestDate:   "",
                RenewedFromOrderID: &amp;order.ID,
                CreatedAt:          now.Format(time.RFC3339),
                UpdatedAt:          now.Format(time.RFC3339),
        }

        query := `
                INSERT INTO wealth_order (user_id, product_id, product_title, currency, amount,
                        auto_renew, status, start_date, end_date,
                        principal_redeemed, interest_expected, interest_paid, interest_accrued,
                        renewed_from_order_id, created_at, updated_at)
                VALUES ($1, $2, $3, $4, $5, $6, 1, $7, $8, '0', $9, '0', '0', $10, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
                RETURNING id
        `
        err := r.db.QueryRowContext(ctx, query,
                newOrder.UserID, newOrder.ProductID, newOrder.ProductTitle, newOrder.Currency, newOrder.Amount,
                newOrder.AutoRenew, newOrder.StartDate, newOrder.EndDate,
                newOrder.InterestExpected, newOrder.RenewedFromOrderID,
        ).Scan(&amp;newOrder.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create renewed order: %v", err)
        }</span>

        <span class="cov0" title="0">updateQuery := `
                UPDATE wealth_order SET
                        renewed_to_order_id = $1,
                        updated_at = NOW()
                WHERE id = $2
        `
        _, err = r.db.ExecContext(ctx, updateQuery, newOrder.ID, order.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update original order: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("[RenewOrder] Order renewed successfully: old_order_id=%d, new_order_id=%d, user_id=%d, amount=%s\n",
                order.ID, newOrder.ID, order.UserID, order.Amount)

        return newOrder, nil</span>
}

type JournalRepository struct {
        db *sql.DB
}

func NewJournalRepository(db *sql.DB) *JournalRepository <span class="cov0" title="0">{
        return &amp;JournalRepository{db: db}
}</span>

func (r *JournalRepository) CreateJournalRecord(ctx context.Context, record *repository.JournalModel) error <span class="cov0" title="0">{
        query := `
                INSERT INTO account_journal (serial_no, user_id, account_id, amount, balance_snapshot, biz_type, ref_id, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, COALESCE($8, CURRENT_TIMESTAMP))
        `
        _, err := r.db.ExecContext(ctx, query,
                record.SerialNo,
                record.UserID,
                record.AccountID,
                record.Amount,
                record.BalanceSnapshot,
                record.BizType,
                record.RefID,
                record.CreatedAt,
        )
        return err
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package postgres

import (
        "context"
        "database/sql"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type WithdrawalRepository struct {
        db *sql.DB
}

func NewWithdrawalRepository(db *sql.DB) repository.Withdrawal <span class="cov8" title="1">{
        return &amp;WithdrawalRepository{db: db}
}</span>

func (r *WithdrawalRepository) CreateOrder(ctx context.Context, order *models.WithdrawalOrder) (*models.WithdrawalOrder, error) <span class="cov8" title="1">{
        err := r.db.QueryRowContext(ctx,
                `INSERT INTO withdrawal_order (
                        user_id, amount, network_fee, platform_fee, actual_amount,
                        chain_type, coin_type, to_address, safeheron_order_id, transaction_hash,
                        status, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                RETURNING id, created_at`,
                order.UserID, order.Amount, order.NetworkFee, order.PlatformFee, order.ActualAmount,
                order.ChainType, order.CoinType, order.ToAddress, order.SafeheronOrderID, order.TransactionHash,
                order.Status, time.Now(), time.Now(),
        ).Scan(&amp;order.ID, &amp;order.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return order, nil</span>
}

func (r *WithdrawalRepository) GetOrdersByUserID(ctx context.Context, userID int) ([]*models.WithdrawalOrder, error) <span class="cov0" title="0">{
        rows, err := r.db.QueryContext(ctx,
                `SELECT id, user_id, amount, network_fee, platform_fee, actual_amount,
                        chain_type, coin_type, to_address, safeheron_order_id, transaction_hash,
                        status, created_at, sent_at, confirmed_at, completed_at, updated_at
                FROM withdrawal_order WHERE user_id = $1 ORDER BY created_at DESC`,
                userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        orders := make([]*models.WithdrawalOrder, 0, 50)
        for rows.Next() </span><span class="cov0" title="0">{
                var o models.WithdrawalOrder
                if err := rows.Scan(
                        &amp;o.ID, &amp;o.UserID, &amp;o.Amount, &amp;o.NetworkFee, &amp;o.PlatformFee, &amp;o.ActualAmount,
                        &amp;o.ChainType, &amp;o.CoinType, &amp;o.ToAddress, &amp;o.SafeheronOrderID, &amp;o.TransactionHash,
                        &amp;o.Status, &amp;o.CreatedAt, &amp;o.SentAt, &amp;o.ConfirmedAt, &amp;o.CompletedAt, &amp;o.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">orders = append(orders, &amp;o)</span>
        }
        <span class="cov0" title="0">return orders, nil</span>
}

func (r *WithdrawalRepository) GetOrderByID(ctx context.Context, id int) (*models.WithdrawalOrder, error) <span class="cov0" title="0">{
        var o models.WithdrawalOrder
        err := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, amount, network_fee, platform_fee, actual_amount,
                        chain_type, coin_type, to_address, safeheron_order_id, transaction_hash,
                        status, created_at, sent_at, confirmed_at, completed_at, updated_at
                FROM withdrawal_order WHERE id = $1`,
                id).Scan(
                &amp;o.ID, &amp;o.UserID, &amp;o.Amount, &amp;o.NetworkFee, &amp;o.PlatformFee, &amp;o.ActualAmount,
                &amp;o.ChainType, &amp;o.CoinType, &amp;o.ToAddress, &amp;o.SafeheronOrderID, &amp;o.TransactionHash,
                &amp;o.Status, &amp;o.CreatedAt, &amp;o.SentAt, &amp;o.ConfirmedAt, &amp;o.CompletedAt, &amp;o.UpdatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;o, nil</span>
}

func (r *WithdrawalRepository) UpdateOrder(ctx context.Context, order *models.WithdrawalOrder) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `UPDATE withdrawal_order SET
                        status = $1, transaction_hash = $2, sent_at = $3,
                        confirmed_at = $4, completed_at = $5, updated_at = $6
                WHERE id = $7`,
                order.Status, order.TransactionHash, order.SentAt,
                order.ConfirmedAt, order.CompletedAt, time.Now(), order.ID)
        return err
}</span>

func (r *WithdrawalRepository) CreateRequest(ctx context.Context, req *models.WithdrawalRequest) error <span class="cov0" title="0">{
        err := r.db.QueryRowContext(ctx,
                `INSERT INTO withdrawal_request (user_id, request_id, status, error_code, error_message, created_at)
                VALUES ($1, $2, $3, $4, $5, $6) RETURNING id`,
                req.UserID, req.RequestID, req.Status, req.ErrorCode, req.ErrorMessage, time.Now(),
        ).Scan(&amp;req.ID)
        return err
}</span>

func (r *WithdrawalRepository) GetRequestByID(ctx context.Context, requestID string) (*models.WithdrawalRequest, error) <span class="cov0" title="0">{
        var req models.WithdrawalRequest
        err := r.db.QueryRowContext(ctx,
                `SELECT id, user_id, request_id, status, error_code, error_message, created_at
                FROM withdrawal_request WHERE request_id = $1`,
                requestID).Scan(
                &amp;req.ID, &amp;req.UserID, &amp;req.RequestID, &amp;req.Status, &amp;req.ErrorCode, &amp;req.ErrorMessage, &amp;req.CreatedAt,
        )
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, repository.ErrNotFound
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;req, nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// internal/routes/routes.go
package routes

import (
        "os"

        "github.com/gin-gonic/gin"
        swaggerFiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
        "monera-digital/internal/account"
        "monera-digital/internal/container"
        "monera-digital/internal/docs"
        "monera-digital/internal/handlers"
        "monera-digital/internal/handlers/core"
        "monera-digital/internal/middleware"
)

// SetupRoutes configures all API routes with middleware
func SetupRoutes(router *gin.Engine, cont *container.Container) <span class="cov0" title="0">{
        // Add global middleware
        router.Use(middleware.RecoveryHandler())
        router.Use(middleware.ErrorHandler())
        router.Use(middleware.RateLimitMiddleware(cont.RateLimiter))

        // Initialize Swagger documentation
        docs.NewSwagger()

        // Swagger documentation endpoint
        router.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

        // Create handler
        h := handlers.NewHandler(
                cont.AuthService,
                cont.LendingService,
                cont.AddressService,
                cont.WithdrawalService,
                cont.DepositService,
                cont.WalletService,
                cont.WealthService,
        )

        // Create 2FA handler
        twofaHandler := handlers.NewTwoFAHandler(cont.TwoFAService)

        // Account System Client - Use BACKEND_URL from environment, default to localhost for backward compatibility
        accountBaseURL := os.Getenv("BACKEND_URL")
        if accountBaseURL == "" </span><span class="cov0" title="0">{
                accountBaseURL = "http://localhost:8081"
        }</span>
        <span class="cov0" title="0">accountClient := account.NewClient(accountBaseURL)
        accountHandler := &amp;handlers.AccountHandler{Client: accountClient}

        // Public routes
        public := router.Group("/api")
        </span><span class="cov0" title="0">{
                // API Health check
                public.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                        c.JSON(200, gin.H{"status": "ok"})
                }</span>)

                <span class="cov0" title="0">auth := public.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.POST("/register", h.Register)
                        auth.POST("/login", h.Login)
                        auth.POST("/refresh", h.RefreshToken)
                        auth.POST("/logout", h.Logout)
                        // 2FA验证登录 - 公开端点，因为此时还没有JWT
                        auth.POST("/2fa/verify-login", h.Verify2FALogin)
                        // 跳过2FA设置 - 公开端点
                        auth.POST("/2fa/skip", h.Skip2FALogin)
                }</span>

                <span class="cov0" title="0">webhooks := public.Group("/webhooks")
                </span><span class="cov0" title="0">{
                        webhooks.POST("/core/deposit", h.HandleDepositWebhook)
                }</span>

                // Account System Routes
                <span class="cov0" title="0">accounts := public.Group("/accounts")
                </span><span class="cov0" title="0">{
                        accounts.GET("", accountHandler.GetUserAccounts)
                        accounts.POST("", accountHandler.CreateAccount)
                        accounts.GET("/history", accountHandler.GetAccountHistory)
                        accounts.POST("/freeze", accountHandler.FreezeBalance)
                        accounts.POST("/unfreeze", accountHandler.UnfreezeBalance)
                        accounts.POST("/transfer", accountHandler.Transfer)
                }</span>
        }

        // Protected routes
        <span class="cov0" title="0">protected := router.Group("/api")
        protected.Use(middleware.AuthMiddleware(cont.JWTSecret))
        </span><span class="cov0" title="0">{
                auth := protected.Group("/auth")
                </span><span class="cov0" title="0">{
                        auth.GET("/me", h.GetMe)
                        twofa := auth.Group("/2fa")
                        </span><span class="cov0" title="0">{
                                twofa.POST("/setup", twofaHandler.Setup2FA)
                                twofa.POST("/enable", twofaHandler.Enable2FA)
                                twofa.POST("/verify", twofaHandler.Verify2FA)
                                twofa.POST("/disable", twofaHandler.Disable2FA)
                                twofa.GET("/status", twofaHandler.Get2FAStatus)
                        }</span>
                }

                <span class="cov0" title="0">lending := protected.Group("/lending")
                </span><span class="cov0" title="0">{
                        lending.POST("/apply", h.ApplyForLending)
                        lending.GET("/positions", h.GetUserPositions)
                }</span>

                <span class="cov0" title="0">wallet := protected.Group("/wallet")
                </span><span class="cov0" title="0">{
                        wallet.GET("/info", h.GetWalletInfo)
                        wallet.POST("/create", h.CreateWallet)
                        wallet.POST("/addresses", h.AddWalletAddress)
                        wallet.POST("/address/incomeHistory", h.GetAddressIncomeHistory)
                        wallet.POST("/address/get", h.GetWalletAddress)
                }</span>

                <span class="cov0" title="0">deposits := protected.Group("/deposits")
                </span><span class="cov0" title="0">{
                        deposits.GET("", h.GetDeposits)
                }</span>

                <span class="cov0" title="0">addresses := protected.Group("/addresses")
                </span><span class="cov0" title="0">{
                        addresses.GET("", h.GetAddresses)
                        addresses.POST("", h.AddAddress)
                        addresses.POST("/:id/verify", h.VerifyAddress)
                        addresses.POST("/:id/set-primary", h.SetPrimaryAddress)
                        addresses.POST("/:id/deactivate", h.DeactivateAddress)
                }</span>

                <span class="cov0" title="0">withdrawals := protected.Group("/withdrawals")
                </span><span class="cov0" title="0">{
                        withdrawals.GET("", h.GetWithdrawals)
                        withdrawals.POST("", h.CreateWithdrawal)
                        withdrawals.GET("/fees", h.GetWithdrawalFees)
                        withdrawals.GET("/:id", h.GetWithdrawalByID)
                }</span>

                <span class="cov0" title="0">assets := protected.Group("/assets")
                </span><span class="cov0" title="0">{
                        assets.GET("", h.GetAssets)
                        assets.POST("/refresh-prices", h.RefreshPrices)
                }</span>

                <span class="cov0" title="0">wealth := protected.Group("/wealth")
                </span><span class="cov0" title="0">{
                        wealth.GET("/products", h.GetProducts)
                        wealth.POST("/subscribe", h.Subscribe)
                        wealth.GET("/orders", h.GetOrders)
                        wealth.POST("/redeem", h.Redeem)
                }</span>
        }

        // Health check endpoint
        <span class="cov0" title="0">router.GET("/health", func(c *gin.Context) </span><span class="cov0" title="0">{
                c.JSON(200, gin.H{"status": "ok"})
        }</span>)

        // Core Account System Mock API
        <span class="cov0" title="0">core.SetupRoutes(router)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package scheduler

import (
        "context"
        "fmt"
        "strconv"
        "time"

        "monera-digital/internal/binance"
        "monera-digital/internal/logger"
        "monera-digital/internal/repository"
)

type InterestScheduler struct {
        repo         repository.Wealth
        accountRepo  repository.AccountV2
        journalRepo  repository.Journal
        priceService *binance.PriceService
        metrics      *SchedulerMetrics
}

func NewInterestScheduler(wealthRepo repository.Wealth, accountRepo repository.AccountV2, journalRepo repository.Journal) *InterestScheduler <span class="cov0" title="0">{
        return &amp;InterestScheduler{
                repo:         wealthRepo,
                accountRepo:  accountRepo,
                journalRepo:  journalRepo,
                priceService: binance.NewPriceService(),
                metrics:      NewSchedulerMetrics(),
        }
}</span>

func (s *InterestScheduler) Start() <span class="cov0" title="0">{
        loc := GetShanghaiLocation()

        nextMidnight := time.Now().In(loc)
        if nextMidnight.Hour() &gt;= 0 </span><span class="cov0" title="0">{
                nextMidnight = nextMidnight.AddDate(0, 0, 1)
        }</span>
        <span class="cov0" title="0">nextMidnight = time.Date(nextMidnight.Year(), nextMidnight.Month(), nextMidnight.Day(), 0, 0, 0, 0, loc)

        duration := nextMidnight.Sub(time.Now().In(loc))
        logger.Info("[InterestScheduler] First run scheduled",
                "scheduled_time", nextMidnight.Format("2006-01-02 15:04:05"),
                "delay_seconds", duration.Seconds())

        ticker := time.NewTicker(24 * time.Hour)
        defer ticker.Stop()

        time.Sleep(duration)

        logger.Info("[InterestScheduler] Started - running daily at 00:00 Asia/Shanghai")

        for range ticker.C </span><span class="cov0" title="0">{
                now := NowInShanghai()
                logger.Info("[InterestScheduler] Execution started", "timestamp", now.Format("2006-01-02 15:04:05"))

                ctx := context.Background()

                // Step 1: Calculate daily interest
                ordersProcessed, interestAccrued, err := s.CalculateDailyInterest(ctx)

                // Step 2: Settle expired orders
                settledCount, settleErr := s.SettleExpiredOrders(ctx)

                success := err == nil &amp;&amp; settleErr == nil
                errorMsg := ""
                if err != nil </span><span class="cov0" title="0">{
                        errorMsg = err.Error()
                }</span>
                <span class="cov0" title="0">if settleErr != nil </span><span class="cov0" title="0">{
                        if errorMsg != "" </span><span class="cov0" title="0">{
                                errorMsg += "; "
                        }</span>
                        <span class="cov0" title="0">errorMsg += fmt.Sprintf("settle error: %v", settleErr)</span>
                }

                <span class="cov0" title="0">s.metrics.RecordInterestRun(success, ordersProcessed, interestAccrued, errorMsg)

                if !success </span><span class="cov0" title="0">{
                        logger.Error("[InterestScheduler] Execution failed", "error", errorMsg)
                }</span> else<span class="cov0" title="0"> {
                        logger.Info("[InterestScheduler] Execution completed",
                                "orders_processed", ordersProcessed,
                                "interest_accrued", interestAccrued,
                                "orders_settled", settledCount)
                }</span>
        }
}

func (s *InterestScheduler) CalculateDailyInterest(ctx context.Context) (int, float64, error) <span class="cov8" title="1">{
        logger.Info("[InterestScheduler] Calculating daily interest...")

        today := TodayInShanghai()

        orders, err := s.repo.GetActiveOrders(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return 0, 0, fmt.Errorf("failed to get active orders: %v", err)
        }</span>

        <span class="cov8" title="1">logger.Info("[InterestScheduler] Found active orders", "count", len(orders))

        ordersProcessed := 0
        totalInterestAccrued := 0.0

        for _, order := range orders </span><span class="cov8" title="1">{
                if order.StartDate == today </span><span class="cov8" title="1">{
                        logger.Debug("[InterestScheduler] Order skipped - start date is today",
                                "order_id", order.ID, "start_date", today)
                        continue</span>
                }

                <span class="cov8" title="1">if order.LastInterestDate == today </span><span class="cov8" title="1">{
                        logger.Debug("[InterestScheduler] Order skipped - interest already calculated today",
                                "order_id", order.ID)
                        continue</span>
                }

                <span class="cov8" title="1">product, err := s.repo.GetProductByID(ctx, order.ProductID)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("[InterestScheduler] Failed to get product",
                                "order_id", order.ID, "error", err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">apy, _ := strconv.ParseFloat(product.APY, 64)
                amount, _ := strconv.ParseFloat(order.Amount, 64)

                dailyInterest := amount * (apy / 100) / 365

                err = s.repo.AccrueInterest(ctx, order.ID, strconv.FormatFloat(dailyInterest, 'f', -1, 64), today)
                if err != nil </span><span class="cov8" title="1">{
                        logger.Error("[InterestScheduler] Failed to accrue interest",
                                "order_id", order.ID, "error", err.Error())
                        continue</span>
                }

                <span class="cov8" title="1">ordersProcessed++
                totalInterestAccrued += dailyInterest

                logger.Info("[InterestScheduler] Interest accrued",
                        "order_id", order.ID,
                        "interest", dailyInterest,
                        "currency", order.Currency,
                        "apy", apy,
                        "amount", amount)</span>
        }

        <span class="cov8" title="1">logger.Info("[InterestScheduler] Daily interest calculation completed",
                "orders_processed", ordersProcessed,
                "total_interest", totalInterestAccrued)

        return ordersProcessed, totalInterestAccrued, nil</span>
}

func (s *InterestScheduler) SettleOrder(ctx context.Context, orderID int64) error <span class="cov8" title="1">{
        logger.Info("[InterestScheduler] Settling order", "order_id", orderID)

        order, err := s.repo.GetOrderByID(ctx, orderID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get order: %v", err)
        }</span>

        <span class="cov8" title="1">if order.Status != 1 </span><span class="cov8" title="1">{
                return fmt.Errorf("order status is not active: %d", order.Status)
        }</span>

        <span class="cov8" title="1">account, err := s.accountRepo.GetAccountByUserIDAndCurrency(ctx, order.UserID, order.Currency)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get account: %v", err)
        }</span>

        <span class="cov8" title="1">now := time.Now()

        // Step 1: Unfreeze principal
        err = s.accountRepo.UnfreezeBalance(ctx, account.ID, order.Amount)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to unfreeze balance: %v", err)
        }</span>

        // Generate journal record for principal unfreeze
        <span class="cov8" title="1">balance, _ := strconv.ParseFloat(account.Balance, 64)
        principalAmt, _ := strconv.ParseFloat(order.Amount, 64)
        newBalance := balance + principalAmt

        principalJournal := &amp;repository.JournalModel{
                SerialNo:        fmt.Sprintf("SETTLE-PRINCIPAL-%s-%d", now.Format("20060102150405"), order.ID),
                UserID:          order.UserID,
                AccountID:       account.ID,
                Amount:          order.Amount,
                BalanceSnapshot: strconv.FormatFloat(newBalance, 'f', -1, 64),
                BizType:         "REDEEM_UNFREEZE",
                RefID:           &amp;order.ID,
                CreatedAt:       now.Format(time.RFC3339),
        }
        err = s.journalRepo.CreateJournalRecord(ctx, principalJournal)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("[InterestScheduler] Failed to create principal journal record",
                        "order_id", orderID, "error", err.Error())
        }</span>

        // Step 2: Pay interest if accrued
        <span class="cov8" title="1">interestPaid, _ := strconv.ParseFloat(order.InterestAccrued, 64)
        if interestPaid &gt; 0 </span><span class="cov8" title="1">{
                err = s.accountRepo.AddBalance(ctx, account.ID, strconv.FormatFloat(interestPaid, 'f', -1, 64))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add interest to balance: %v", err)
                }</span>

                // Generate journal record for interest payout
                <span class="cov8" title="1">balanceAfterInterest := newBalance + interestPaid
                interestJournal := &amp;repository.JournalModel{
                        SerialNo:        fmt.Sprintf("SETTLE-INTEREST-%s-%d", now.Format("20060102150405"), order.ID),
                        UserID:          order.UserID,
                        AccountID:       account.ID,
                        Amount:          strconv.FormatFloat(interestPaid, 'f', -1, 64),
                        BalanceSnapshot: strconv.FormatFloat(balanceAfterInterest, 'f', -1, 64),
                        BizType:         "INTEREST_PAYOUT",
                        RefID:           &amp;order.ID,
                        CreatedAt:       now.Format(time.RFC3339),
                }
                err = s.journalRepo.CreateJournalRecord(ctx, interestJournal)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("[InterestScheduler] Failed to create interest journal record",
                                "order_id", orderID, "error", err.Error())
                }</span>
        }

        // Step 3: Update order status
        <span class="cov8" title="1">err = s.repo.SettleOrder(ctx, orderID, strconv.FormatFloat(interestPaid, 'f', -1, 64))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to settle order: %v", err)
        }</span>

        <span class="cov8" title="1">logger.Info("[InterestScheduler] Order settled",
                "order_id", orderID,
                "amount_unfrozen", order.Amount,
                "currency", order.Currency,
                "interest_paid", interestPaid)

        return nil</span>
}

// SettleExpiredOrders Find and settle all orders that have expired
func (s *InterestScheduler) SettleExpiredOrders(ctx context.Context) (int, error) <span class="cov8" title="1">{
        today := TodayInShanghai()

        logger.Info("[InterestScheduler] Settling expired orders", "date", today)

        orders, err := s.repo.GetExpiredOrders(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get expired orders: %v", err)
        }</span>

        <span class="cov8" title="1">settledCount := 0
        renewedCount := 0

        for _, order := range orders </span><span class="cov8" title="1">{
                if order.AutoRenew </span><span class="cov8" title="1">{
                        err = s.RenewOrder(ctx, order)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("[InterestScheduler] Failed to renew order",
                                        "order_id", order.ID, "error", err.Error())
                                continue</span>
                        }
                        <span class="cov8" title="1">renewedCount++
                        logger.Info("[InterestScheduler] Order auto-renewed",
                                "order_id", order.ID,
                                "user_id", order.UserID,
                                "amount", order.Amount,
                                "currency", order.Currency)</span>
                } else<span class="cov8" title="1"> {
                        err = s.SettleOrder(ctx, order.ID)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.Error("[InterestScheduler] Failed to settle order",
                                        "order_id", order.ID, "error", err.Error())
                                continue</span>
                        }
                        <span class="cov8" title="1">settledCount++
                        logger.Info("[InterestScheduler] Order auto-settled",
                                "order_id", order.ID,
                                "user_id", order.UserID,
                                "amount", order.Amount,
                                "currency", order.Currency)</span>
                }
        }

        <span class="cov8" title="1">logger.Info("[InterestScheduler] Expired orders settlement completed",
                "settled_count", settledCount,
                "renewed_count", renewedCount)
        return settledCount + renewedCount, nil</span>
}

// RenewOrder Auto-renew an expired order
func (s *InterestScheduler) RenewOrder(ctx context.Context, order *repository.WealthOrderModel) error <span class="cov8" title="1">{
        logger.Info("[InterestScheduler] Renewing order", "order_id", order.ID)

        // Get product info
        product, err := s.repo.GetProductByID(ctx, order.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get product: %v", err)
        }</span>

        // Check if product is still available
        <span class="cov8" title="1">if product.Status != 1 </span><span class="cov0" title="0">{
                logger.Warn("[InterestScheduler] Product not available for renewal, settling normally",
                        "order_id", order.ID, "product_id", product.ID)
                return s.SettleOrder(ctx, order.ID)
        }</span>

        // Check if auto-renew is still allowed
        <span class="cov8" title="1">if !product.AutoRenewAllowed </span><span class="cov0" title="0">{
                logger.Warn("[InterestScheduler] Auto-renew not allowed for product, settling normally",
                        "order_id", order.ID, "product_id", product.ID)
                return s.SettleOrder(ctx, order.ID)
        }</span>

        // Get user account
        <span class="cov8" title="1">account, err := s.accountRepo.GetAccountByUserIDAndCurrency(ctx, order.UserID, order.Currency)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get account: %v", err)
        }</span>

        <span class="cov8" title="1">now := time.Now()

        // Step 1: Pay interest from old order
        interestPaid, _ := strconv.ParseFloat(order.InterestAccrued, 64)
        if interestPaid &gt; 0 </span><span class="cov8" title="1">{
                err = s.accountRepo.AddBalance(ctx, account.ID, strconv.FormatFloat(interestPaid, 'f', -1, 64))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add interest: %v", err)
                }</span>

                // Generate journal record for interest payout
                <span class="cov8" title="1">balance, _ := strconv.ParseFloat(account.Balance, 64)
                interestJournal := &amp;repository.JournalModel{
                        SerialNo:        fmt.Sprintf("RENEW-INTEREST-%s-%d", now.Format("20060102150405"), order.ID),
                        UserID:          order.UserID,
                        AccountID:       account.ID,
                        Amount:          strconv.FormatFloat(interestPaid, 'f', -1, 64),
                        BalanceSnapshot: strconv.FormatFloat(balance+interestPaid, 'f', -1, 64),
                        BizType:         "INTEREST_PAYOUT",
                        RefID:           &amp;order.ID,
                        CreatedAt:       now.Format(time.RFC3339),
                }
                err = s.journalRepo.CreateJournalRecord(ctx, interestJournal)
                if err != nil </span><span class="cov0" title="0">{
                        logger.Error("[InterestScheduler] Failed to create interest journal record",
                                "order_id", order.ID, "error", err.Error())
                }</span>
        }

        // Step 2: Create new order (principal stays frozen)
        <span class="cov8" title="1">newOrder, err := s.repo.RenewOrder(ctx, order, product)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create renewed order: %v", err)
        }</span>

        // Generate journal record for new subscription
        <span class="cov8" title="1">balanceAfterInterest, _ := strconv.ParseFloat(account.Balance, 64)
        subscribeJournal := &amp;repository.JournalModel{
                SerialNo:        fmt.Sprintf("RENEW-SUBSCRIBE-%s-%d", now.Format("20060102150405"), newOrder.ID),
                UserID:          order.UserID,
                AccountID:       account.ID,
                Amount:          "-" + newOrder.Amount,
                BalanceSnapshot: strconv.FormatFloat(balanceAfterInterest-float64(interestPaid), 'f', -1, 64),
                BizType:         "SUBSCRIBE_FREEZE",
                RefID:           &amp;newOrder.ID,
                CreatedAt:       now.Format(time.RFC3339),
        }
        err = s.journalRepo.CreateJournalRecord(ctx, subscribeJournal)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("[InterestScheduler] Failed to create subscription journal record",
                        "order_id", newOrder.ID, "error", err.Error())
        }</span>

        // Step 3: Update old order status
        <span class="cov8" title="1">err = s.repo.SettleOrder(ctx, order.ID, strconv.FormatFloat(interestPaid, 'f', -1, 64))
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("[InterestScheduler] Failed to update old order status",
                        "order_id", order.ID, "error", err.Error())
        }</span>

        <span class="cov8" title="1">logger.Info("[InterestScheduler] Order renewed successfully",
                "old_order_id", order.ID,
                "new_order_id", newOrder.ID,
                "amount", order.Amount,
                "currency", order.Currency,
                "interest_paid", interestPaid)

        return nil</span>
}

func (s *InterestScheduler) GetMetrics() *SchedulerMetrics <span class="cov0" title="0">{
        return s.metrics
}</span>
</pre>
		
		<pre class="file" id="file48" style="display: none">// internal/scheduler/metrics.go
package scheduler

import (
        "sync"
        "time"
)

type SchedulerMetrics struct {
        mu sync.RWMutex

        InterestRunCount      int64
        InterestSuccessCount  int64
        InterestErrorCount    int64
        TotalOrdersProcessed  int64
        TotalInterestAccrued  float64
        LastRunTime           time.Time
        LastSuccessTime       time.Time
        LastErrorTime         time.Time
        LastErrorMessage      string
        AverageOrdersPerRun   float64
        AverageInterestPerRun float64
}

func NewSchedulerMetrics() *SchedulerMetrics <span class="cov8" title="1">{
        return &amp;SchedulerMetrics{}
}</span>

func (m *SchedulerMetrics) RecordInterestRun(success bool, ordersProcessed int, interestAccrued float64, errorMsg string) <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.InterestRunCount++
        m.TotalOrdersProcessed += int64(ordersProcessed)
        m.TotalInterestAccrued += interestAccrued
        m.LastRunTime = time.Now()

        if success </span><span class="cov8" title="1">{
                m.InterestSuccessCount++
                m.LastSuccessTime = time.Now()
        }</span> else<span class="cov8" title="1"> {
                m.InterestErrorCount++
                m.LastErrorTime = time.Now()
                m.LastErrorMessage = errorMsg
        }</span>

        <span class="cov8" title="1">m.updateAverages()</span>
}

func (m *SchedulerMetrics) updateAverages() <span class="cov8" title="1">{
        if m.InterestRunCount == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">m.AverageOrdersPerRun = float64(m.TotalOrdersProcessed) / float64(m.InterestRunCount)
        m.AverageInterestPerRun = m.TotalInterestAccrued / float64(m.InterestRunCount)</span>
}

func (m *SchedulerMetrics) GetSnapshot() map[string]interface{} <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        return map[string]interface{}{
                "interest_run_count":       m.InterestRunCount,
                "interest_success_count":   m.InterestSuccessCount,
                "interest_error_count":     m.InterestErrorCount,
                "success_rate":             m.getSuccessRate(),
                "total_orders_processed":   m.TotalOrdersProcessed,
                "total_interest_accrued":   m.TotalInterestAccrued,
                "average_orders_per_run":   m.AverageOrdersPerRun,
                "average_interest_per_run": m.AverageInterestPerRun,
                "last_run_time":            m.LastRunTime.Format(time.RFC3339),
                "last_success_time":        m.formatTime(m.LastSuccessTime),
                "last_error_time":          m.formatTime(m.LastErrorTime),
                "last_error_message":       m.LastErrorMessage,
        }
}</span>

func (m *SchedulerMetrics) getSuccessRate() float64 <span class="cov8" title="1">{
        if m.InterestRunCount == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return float64(m.InterestSuccessCount) / float64(m.InterestRunCount) * 100</span>
}

func (m *SchedulerMetrics) formatTime(t time.Time) string <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov8" title="1">{
                return "never"
        }</span>
        <span class="cov8" title="1">return t.Format(time.RFC3339)</span>
}

func (m *SchedulerMetrics) Reset() <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.InterestRunCount = 0
        m.InterestSuccessCount = 0
        m.InterestErrorCount = 0
        m.TotalOrdersProcessed = 0
        m.TotalInterestAccrued = 0
        m.LastRunTime = time.Time{}
        m.LastSuccessTime = time.Time{}
        m.LastErrorTime = time.Time{}
        m.LastErrorMessage = ""
        m.AverageOrdersPerRun = 0
        m.AverageInterestPerRun = 0
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package scheduler

import (
        "sync"
        "time"

        "monera-digital/internal/logger"
)

// Shanghai timezone: UTC+8 (China does not observe DST)
const shanghaiOffsetSeconds = 8 * 60 * 60

var (
        shanghaiLocation     *time.Location
        shanghaiLocationOnce sync.Once
)

// GetShanghaiLocation returns Asia/Shanghai timezone location.
// Falls back to a fixed UTC+8 offset if timezone database is unavailable.
// This is critical for deployment environments that lack tzdata.
func GetShanghaiLocation() *time.Location <span class="cov8" title="1">{
        shanghaiLocationOnce.Do(func() </span><span class="cov8" title="1">{
                loc, err := time.LoadLocation("Asia/Shanghai")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Warn("[Timezone] Failed to load Asia/Shanghai timezone, using UTC+8 fallback",
                                "error", err.Error())
                        loc = time.FixedZone("Asia/Shanghai", shanghaiOffsetSeconds)
                }</span>
                <span class="cov8" title="1">shanghaiLocation = loc</span>
        })
        <span class="cov8" title="1">return shanghaiLocation</span>
}

// NowInShanghai returns the current time in Asia/Shanghai timezone.
func NowInShanghai() time.Time <span class="cov8" title="1">{
        return time.Now().In(GetShanghaiLocation())
}</span>

// TodayInShanghai returns today's date string (YYYY-MM-DD) in Asia/Shanghai timezone.
func TodayInShanghai() string <span class="cov8" title="1">{
        return NowInShanghai().Format("2006-01-02")
}</span>

// resetShanghaiLocation resets the cached location for testing.
// This is unexported intentionally - only used in tests.
func resetShanghaiLocation() <span class="cov8" title="1">{
        shanghaiLocationOnce = sync.Once{}
        shanghaiLocation = nil
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "time"

        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type AddressService struct {
        repo repository.Address
}

func NewAddressService(repo repository.Address) *AddressService <span class="cov0" title="0">{
        return &amp;AddressService{repo: repo}
}</span>

func (s *AddressService) GetAddresses(ctx context.Context, userID int) ([]*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        return s.repo.GetAddressesByUserID(ctx, userID)
}</span>

func (s *AddressService) AddAddress(ctx context.Context, userID int, req models.AddAddressRequest) (*models.WithdrawalAddress, error) <span class="cov0" title="0">{
        // Check if already exists (optional, unique constraint handles it but maybe check alias?)
        // DB Unique Constraint: (user_id, wallet_address)

        addr := &amp;models.WithdrawalAddress{
                UserID:        userID,
                AddressAlias:  req.AddressAlias,
                ChainType:     req.ChainType,
                WalletAddress: req.WalletAddress,
                Verified:      false, // New addresses need verification
                // VerifiedAt: nil
                // VerificationMethod: nil
        }

        // PRD 4.1: If first time, needs verification. (Default verified=false)
        // If existing whitelist, maybe skip?
        // But AddAddress implies adding new.

        createdAddr, err := s.repo.CreateAddress(ctx, addr)
        if err != nil </span><span class="cov0" title="0">{
                if err == repository.ErrAlreadyExists </span><span class="cov0" title="0">{
                        return nil, errors.New("address already exists")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">return createdAddr, nil</span>
}

func (s *AddressService) VerifyAddress(ctx context.Context, userID int, addressID int, method string) error <span class="cov0" title="0">{
        addr, err := s.repo.GetAddressByID(ctx, addressID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if addr.UserID != userID </span><span class="cov0" title="0">{
                return errors.New("address not found")
        }</span>

        <span class="cov0" title="0">addr.Verified = true
        now := time.Now()
        addr.VerifiedAt = sql.NullTime{Time: now, Valid: true}
        addr.VerificationMethod = sql.NullString{String: method, Valid: true}

        return s.repo.UpdateAddress(ctx, addr)</span>
}

func (s *AddressService) DeleteAddress(ctx context.Context, userID int, addressID int) error <span class="cov0" title="0">{
        addr, err := s.repo.GetAddressByID(ctx, addressID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if addr.UserID != userID </span><span class="cov0" title="0">{
                return errors.New("address not found")
        }</span>

        <span class="cov0" title="0">return s.repo.DeleteAddress(ctx, addressID)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package services

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "strconv"
        "time"

        "monera-digital/internal/cache"
        "monera-digital/internal/config"
        "monera-digital/internal/models"
        "monera-digital/internal/utils"
)

// AuthService provides authentication functionality
type AuthService struct {
        DB               *sql.DB
        jwtSecret        string
        tokenBlacklist   *cache.TokenBlacklist
        twoFactorService *TwoFactorService
}

// NewAuthService creates a new AuthService instance
func NewAuthService(db *sql.DB, jwtSecret string) *AuthService <span class="cov8" title="1">{
        return &amp;AuthService{
                DB:        db,
                jwtSecret: jwtSecret,
        }
}</span>

// SetTwoFactorService injects TwoFactorService dependency
func (s *AuthService) SetTwoFactorService(twoFactor *TwoFactorService) <span class="cov0" title="0">{
        s.twoFactorService = twoFactor
}</span>

// SetTokenBlacklist sets the token blacklist for logout functionality
func (s *AuthService) SetTokenBlacklist(tb *cache.TokenBlacklist) <span class="cov8" title="1">{
        s.tokenBlacklist = tb
}</span>

// LoginResponse represents the login API response
type LoginResponse struct {
        User         *models.User `json:"user,omitempty"`
        Token        string       `json:"token,omitempty"`
        AccessToken  string       `json:"accessToken,omitempty"`
        RefreshToken string       `json:"refreshToken,omitempty"`
        TokenType    string       `json:"tokenType,omitempty"`
        ExpiresIn    int          `json:"expiresIn,omitempty"`
        ExpiresAt    time.Time    `json:"expiresAt,omitempty"`
        Requires2FA  bool         `json:"requires2FA,omitempty"`
        UserID       int          `json:"userId,omitempty"`
}

// Register handles user registration
func (s *AuthService) Register(req models.RegisterRequest) (*models.User, error) <span class="cov8" title="1">{
        // Check if email already exists
        var exists bool
        err := s.DB.QueryRow("SELECT EXISTS(SELECT 1 FROM users WHERE email = $1)", req.Email).Scan(&amp;exists)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                return nil, errors.New("email already registered")
        }</span>

        // Hash password
        <span class="cov8" title="1">hashedPassword, err := utils.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Insert user into database
        <span class="cov8" title="1">var user models.User
        query := `
                INSERT INTO users (email, password, created_at)
                VALUES ($1, $2, NOW())
                RETURNING id, email, created_at, two_factor_enabled`

        err = s.DB.QueryRow(query, req.Email, hashedPassword).Scan(
                &amp;user.ID, &amp;user.Email, &amp;user.CreatedAt, &amp;user.TwoFactorEnabled,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create account in Core Account System (fire and forget)
        <span class="cov8" title="1">_, _ = s.createCoreAccount(user.ID, req.Email)

        return &amp;user, nil</span>
}

// createCoreAccount creates an account in the Core Account System
func (s *AuthService) createCoreAccount(userID int, email string) (string, error) <span class="cov8" title="1">{
        accountReq := map[string]interface{}{
                "externalId":  strconv.Itoa(userID),
                "accountType": "INDIVIDUAL",
                "profile": map[string]interface{}{
                        "email":     email,
                        "firstName": "",
                        "lastName":  "",
                },
                "metadata": map[string]interface{}{
                        "source": "monera_web",
                },
        }

        jsonData, err := json.Marshal(accountReq)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        <span class="cov8" title="1">cfg := config.Load()
        coreAPIURL := fmt.Sprintf("http://localhost:%s/api/core/accounts/create", cfg.Port)

        resp, err := http.Post(coreAPIURL, "application/json", bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("core_simulated_%d", userID), nil
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusCreated </span><span class="cov0" title="0">{
                return "", fmt.Errorf("core account creation failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var response struct {
                Success bool `json:"success"`
                Data    struct {
                        AccountID string `json:"accountId"`
                } `json:"data"`
        }

        if err := json.NewDecoder(resp.Body).Decode(&amp;response); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">return response.Data.AccountID, nil</span>
}

// Login handles user authentication
// Note: 2FA is no longer required during login. It's only required for sensitive operations.
func (s *AuthService) Login(req models.LoginRequest) (*LoginResponse, error) <span class="cov8" title="1">{
        var user models.User
        var hashedPassword string

        query := `SELECT id, email, password, two_factor_enabled FROM users WHERE email = $1`
        err := s.DB.QueryRow(query, req.Email).Scan(&amp;user.ID, &amp;user.Email, &amp;hashedPassword, &amp;user.TwoFactorEnabled)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Verify password
        <span class="cov8" title="1">if !utils.CheckPasswordHash(req.Password, hashedPassword) </span><span class="cov8" title="1">{
                return nil, errors.New("invalid credentials")
        }</span>

        // Generate JWT token directly (no 2FA check during login)
        <span class="cov8" title="1">token, err := utils.GenerateJWT(user.ID, user.Email, s.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">expiresAt := time.Now().Add(24 * time.Hour)

        return &amp;LoginResponse{
                User:        &amp;user,
                Token:       token,
                AccessToken: token,
                TokenType:   "Bearer",
                ExpiresIn:   86400,
                ExpiresAt:   expiresAt,
        }, nil</span>
}

// Verify2FAAndLogin verifies 2FA token and completes login
func (s *AuthService) Verify2FAAndLogin(userID int, token string) (*LoginResponse, error) <span class="cov0" title="0">{
        // 获取用户信息
        user, err := s.GetUserByID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user not found: %w", err)
        }</span>

        // 验证2FA令牌
        <span class="cov0" title="0">valid, err := s.twoFactorService.Verify(userID, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("2FA verification failed: %w", err)
        }</span>
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid 2FA token")
        }</span>

        // 生成JWT令牌
        <span class="cov0" title="0">jwtToken, err := utils.GenerateJWT(user.ID, user.Email, s.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(24 * time.Hour)

        return &amp;LoginResponse{
                User:        user,
                Token:       jwtToken,
                AccessToken: jwtToken,
                TokenType:   "Bearer",
                ExpiresIn:   86400,
                ExpiresAt:   expiresAt,
        }, nil</span>
}

// Skip2FAAndLogin allows skipping 2FA if not enabled and completes login
func (s *AuthService) Skip2FAAndLogin(userID int) (*LoginResponse, error) <span class="cov8" title="1">{
        // 获取用户信息
        user, err := s.GetUserByID(userID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user not found: %w", err)
        }</span>

        // 如果用户已经启用了2FA，则不允许跳过
        <span class="cov8" title="1">if user.TwoFactorEnabled </span><span class="cov8" title="1">{
                return nil, errors.New("cannot skip 2FA as it is enabled for this account")
        }</span>

        // 生成JWT令牌
        <span class="cov8" title="1">jwtToken, err := utils.GenerateJWT(user.ID, user.Email, s.jwtSecret)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov8" title="1">expiresAt := time.Now().Add(24 * time.Hour)

        return &amp;LoginResponse{
                User:        user,
                Token:       jwtToken,
                AccessToken: jwtToken,
                TokenType:   "Bearer",
                ExpiresIn:   86400,
                ExpiresAt:   expiresAt,
        }, nil</span>
}

// Verify2FA verifies a 2FA token for a user
func (s *AuthService) Verify2FA(userID int, token string) (bool, error) <span class="cov0" title="0">{
        if s.twoFactorService == nil </span><span class="cov0" title="0">{
                return false, errors.New("two factor service not initialized")
        }</span>
        <span class="cov0" title="0">return s.twoFactorService.Verify(userID, token)</span>
}

// GetUserByID retrieves a user by their ID
func (s *AuthService) GetUserByID(userID int) (*models.User, error) <span class="cov8" title="1">{
        var user models.User
        query := `SELECT id, email, two_factor_enabled FROM users WHERE id = $1`
        err := s.DB.QueryRow(query, userID).Scan(&amp;user.ID, &amp;user.Email, &amp;user.TwoFactorEnabled)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }
        <span class="cov8" title="1">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">// internal/services/auth_refresh.go
package services

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "monera-digital/internal/models"
)

// RefreshToken 刷新令牌
func (s *AuthService) RefreshToken(refreshToken string) (*models.TokenPair, error) <span class="cov0" title="0">{
        // 1. 验证刷新令牌有效性
        claims := &amp;models.TokenClaims{}
        token, err := jwt.ParseWithClaims(refreshToken, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(s.jwtSecret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil || !token.Valid </span><span class="cov0" title="0">{
                return nil, errors.New("invalid refresh token")
        }</span>

        // 2. 检查令牌类型
        <span class="cov0" title="0">if claims.TokenType != "refresh" </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token type")
        }</span>

        // 3. 检查是否在黑名单中
        <span class="cov0" title="0">if s.tokenBlacklist != nil &amp;&amp; s.tokenBlacklist.IsBlacklisted(refreshToken) </span><span class="cov0" title="0">{
                return nil, errors.New("refresh token has been revoked")
        }</span>

        // 4. 生成新的访问令牌
        <span class="cov0" title="0">accessToken, err := s.generateAccessToken(claims.UserID, claims.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 5. 可选：生成新的刷新令牌（每次刷新都生成新的）
        <span class="cov0" title="0">newRefreshToken, err := s.generateRefreshToken(claims.UserID, claims.Email)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 6. 将旧的刷新令牌加入黑名单
        <span class="cov0" title="0">if s.tokenBlacklist != nil </span><span class="cov0" title="0">{
                s.tokenBlacklist.Add(refreshToken, time.Unix(claims.ExpiresAt, 0))
        }</span>

        <span class="cov0" title="0">return &amp;models.TokenPair{
                AccessToken:  accessToken,
                RefreshToken: newRefreshToken,
                TokenType:    "Bearer",
                ExpiresIn:    900, // 15 分钟
                ExpiresAt:    time.Now().Add(15 * time.Minute),
        }, nil</span>
}

// generateAccessToken 生成访问令牌（15 分钟过期）
func (s *AuthService) generateAccessToken(userID int, email string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(15 * time.Minute)

        claims := &amp;models.TokenClaims{
                UserID:    userID,
                Email:     email,
                TokenType: "access",
                ExpiresAt: expiresAt.Unix(),
                IssuedAt:  now.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>

// generateRefreshToken 生成刷新令牌（7 天过期）
func (s *AuthService) generateRefreshToken(userID int, email string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        expiresAt := now.Add(7 * 24 * time.Hour)

        claims := &amp;models.TokenClaims{
                UserID:    userID,
                Email:     email,
                TokenType: "refresh",
                ExpiresAt: expiresAt.Unix(),
                IssuedAt:  now.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(s.jwtSecret))
}</span>

// Logout 登出（将令牌加入黑名单）
func (s *AuthService) Logout(token string) error <span class="cov0" title="0">{
        if s.tokenBlacklist == nil </span><span class="cov0" title="0">{
                return errors.New("token blacklist not initialized")
        }</span>

        // 解析令牌获取过期时间
        <span class="cov0" title="0">claims := &amp;models.TokenClaims{}
        _, err := jwt.ParseWithClaims(token, claims, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                return []byte(s.jwtSecret), nil
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // 即使令牌无效，也将其加入黑名单
                s.tokenBlacklist.Add(token, time.Now().Add(24*time.Hour))
                return nil
        }</span>

        // 将令牌加入黑名单
        <span class="cov0" title="0">s.tokenBlacklist.Add(token, time.Unix(claims.ExpiresAt, 0))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package services

import (
        "context"
        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type DepositService struct {
        repo repository.Deposit
}

func NewDepositService(repo repository.Deposit) *DepositService <span class="cov8" title="1">{
        return &amp;DepositService{repo: repo}
}</span>

func (s *DepositService) GetDeposits(ctx context.Context, userID int, limit, offset int) ([]*models.Deposit, int64, error) <span class="cov8" title="1">{
        return s.repo.GetByUserID(ctx, userID, limit, offset)
}</span>

func (s *DepositService) HandleWebhook(ctx context.Context, payload map[string]interface{}) error <span class="cov0" title="0">{
        // Implement webhook handling logic
        // 1. Verify signature (skipped for MVP, handled by middleware usually or here)
        // 2. Extract data
        // 3. Update or Insert deposit
        // This requires implementing Upsert logic or Check-then-Insert
        return nil
}</span>
</pre>
		
		<pre class="file" id="file54" style="display: none">package services

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "io"
        "strings"
)

// EncryptionService provides AES-256-GCM encryption for sensitive data
type EncryptionService struct {
        key []byte
}

// DecodeEncryptionKey normalizes encryption key from environment
// Supports two formats:
// - Hex-encoded: 64 hex characters (e.g., "c70c58a23fd8ab7b...") → decodes to 32 bytes
// - Raw string: exactly 32 characters (e.g., "12345678901234567890123456789012") → used as-is
// Returns error if format is invalid or key is wrong length
func DecodeEncryptionKey(keyString string) (string, error) <span class="cov8" title="1">{
        keyString = strings.TrimSpace(keyString)

        if keyString == "" </span><span class="cov8" title="1">{
                return "", errors.New("encryption key cannot be empty")
        }</span>

        // Try to detect format: hex-encoded (64 chars) vs raw (32 chars)
        <span class="cov8" title="1">if len(keyString) == 64 </span><span class="cov8" title="1">{
                // Likely hex-encoded, try to decode
                decodedBytes, err := hex.DecodeString(keyString)
                if err != nil </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("invalid hex format: %w", err)
                }</span>
                <span class="cov8" title="1">if len(decodedBytes) != 32 </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("decoded hex key must be 32 bytes, got %d", len(decodedBytes))
                }</span>
                <span class="cov8" title="1">return string(decodedBytes), nil</span>
        }

        <span class="cov8" title="1">if len(keyString) == 32 </span><span class="cov8" title="1">{
                // Raw 32-byte string, use as-is
                return keyString, nil
        }</span>

        // Invalid length
        <span class="cov8" title="1">return "", fmt.Errorf("encryption key must be either 32 characters (raw) or 64 characters (hex-encoded), got %d", len(keyString))</span>
}

// NewEncryptionService creates a new encryption service
// The key must be 32 bytes for AES-256 (after normalization)
func NewEncryptionService(key string) (*EncryptionService, error) <span class="cov8" title="1">{
        keyBytes := []byte(key)
        if len(keyBytes) != 32 </span><span class="cov8" title="1">{
                return nil, errors.New("encryption key must be exactly 32 bytes")
        }</span>
        <span class="cov8" title="1">return &amp;EncryptionService{key: keyBytes}, nil</span>
}

// Encrypt encrypts plaintext using AES-256-GCM
func (s *EncryptionService) Encrypt(plaintext string) (string, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(s.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate nonce: %w", err)
        }</span>

        <span class="cov8" title="1">ciphertext := gcm.Seal(nonce, nonce, []byte(plaintext), nil)
        return base64.StdEncoding.EncodeToString(ciphertext), nil</span>
}

// Decrypt decrypts ciphertext using AES-256-GCM
func (s *EncryptionService) Decrypt(ciphertext string) (string, error) <span class="cov8" title="1">{
        data, err := base64.StdEncoding.DecodeString(ciphertext)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("invalid base64: %w", err)
        }</span>

        <span class="cov8" title="1">block, err := aes.NewCipher(s.key)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create cipher: %w", err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create GCM: %w", err)
        }</span>

        <span class="cov8" title="1">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov8" title="1">{
                return "", fmt.Errorf("ciphertext too short")
        }</span>

        <span class="cov8" title="1">nonce, ciphertextBytes := data[:nonceSize], data[nonceSize:]
        plaintext, err := gcm.Open(nil, nonce, ciphertextBytes, nil)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("decryption failed: %w", err)
        }</span>

        <span class="cov8" title="1">return string(plaintext), nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package services

import (
        "database/sql"
        "fmt"
        "time"

        "monera-digital/internal/models"
)

type LendingService struct {
        DB *sql.DB
}

func NewLendingService(db *sql.DB) *LendingService <span class="cov0" title="0">{
        return &amp;LendingService{DB: db}
}</span>

func (s *LendingService) CalculateAPY(asset string, durationDays int) string <span class="cov8" title="1">{
        baseRates := map[string]float64{
                "BTC":  4.5,
                "ETH":  5.2,
                "USDT": 8.5,
                "USDC": 8.2,
                "SOL":  6.8,
        }

        baseRate, exists := baseRates[asset]
        if !exists </span><span class="cov8" title="1">{
                baseRate = 5.0
        }</span>

        <span class="cov8" title="1">multiplier := 1.0
        if durationDays &gt;= 360 </span><span class="cov8" title="1">{
                multiplier = 1.5
        }</span> else<span class="cov8" title="1"> if durationDays &gt;= 180 </span><span class="cov8" title="1">{
                multiplier = 1.25
        }</span> else<span class="cov8" title="1"> if durationDays &gt;= 90 </span><span class="cov8" title="1">{
                multiplier = 1.1
        }</span>

        <span class="cov8" title="1">apy := baseRate * multiplier
        return fmt.Sprintf("%.2f", apy)</span>
}

func (s *LendingService) ApplyForLending(userID int, req models.ApplyLendingRequest) (*models.LendingPosition, error) <span class="cov0" title="0">{
        apy := s.CalculateAPY(req.Asset, req.DurationDays)
        startDate := time.Now()
        endDate := startDate.AddDate(0, 0, req.DurationDays)

        query := `
                INSERT INTO lending_positions (user_id, asset, amount, duration_days, apy, status, end_date)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                RETURNING id, user_id, asset, amount, duration_days, apy, status, accrued_yield, start_date, end_date
        `

        var position models.LendingPosition
        err := s.DB.QueryRow(query, userID, req.Asset, req.Amount, req.DurationDays, apy, "ACTIVE", endDate).Scan(
                &amp;position.ID, &amp;position.UserID, &amp;position.Asset, &amp;position.Amount,
                &amp;position.DurationDays, &amp;position.Apy, &amp;position.Status, &amp;position.AccruedYield,
                &amp;position.StartDate, &amp;position.EndDate,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;position, nil</span>
}

func (s *LendingService) GetUserPositions(userID int) ([]models.LendingPosition, error) <span class="cov0" title="0">{
        query := `
                SELECT id, user_id, asset, amount, duration_days, apy, status, accrued_yield, start_date, end_date
                FROM lending_positions
                WHERE user_id = $1
                ORDER BY start_date
        `

        rows, err := s.DB.Query(query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var positions []models.LendingPosition
        for rows.Next() </span><span class="cov0" title="0">{
                var position models.LendingPosition
                err := rows.Scan(
                        &amp;position.ID, &amp;position.UserID, &amp;position.Asset, &amp;position.Amount,
                        &amp;position.DurationDays, &amp;position.Apy, &amp;position.Status, &amp;position.AccruedYield,
                        &amp;position.StartDate, &amp;position.EndDate,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">positions = append(positions, position)</span>
        }

        <span class="cov0" title="0">return positions, nil</span>
}

func (s *LendingService) CalculateEstimatedYield(amount, apy float64, durationDays int) float64 <span class="cov8" title="1">{
        return (amount * (apy / 100) * float64(durationDays)) / 365
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package services

import (
        "context"
)

type SafeheronService struct {
        // config...
}

func NewSafeheronService() *SafeheronService <span class="cov0" title="0">{
        return &amp;SafeheronService{}
}</span>

type SafeheronWithdrawalResponse struct {
        TxHash           string
        SafeheronOrderID string
        NetworkFee       string
}

func (s *SafeheronService) Withdraw(ctx context.Context, req SafeheronWithdrawalRequest) (*SafeheronWithdrawalResponse, error) <span class="cov0" title="0">{
        // Stub implementation
        // In real life, call Safeheron API
        return &amp;SafeheronWithdrawalResponse{
                TxHash:           "0xmocktxhash",
                SafeheronOrderID: "mock-sh-id",
                NetworkFee:       "1.0",
        }, nil
}</span>

type SafeheronWithdrawalRequest struct {
        CoinType  string
        ChainType string
        ToAddress string
        Amount    string
        RequestID string
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package services

import (
        "crypto/rand"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "time"

        "github.com/pquerna/otp"
        "github.com/pquerna/otp/totp"
        "monera-digital/internal/models"
)

// EncryptionProvider interface for dependency injection (KISS: testable)
type EncryptionProvider interface {
        Encrypt(plaintext string) (string, error)
        Decrypt(ciphertext string) (string, error)
}

// TwoFactorService handles 2FA operations (KISS: single responsibility)
type TwoFactorService struct {
        DB interface {
                QueryRow(query string, args ...interface{}) *sql.Row
                Exec(query string, args ...interface{}) (sql.Result, error)
        }
        Encryption EncryptionProvider
}

// SetupResponse contains 2FA setup data returned to the user
type SetupResponse struct {
        Secret      string   `json:"secret"`
        QRCode      string   `json:"qrCodeUrl"`
        BackupCodes []string `json:"backupCodes"`
        OTPAuth     string   `json:"otpauth"`
}

// NewTwoFactorService creates a new 2FA service
func NewTwoFactorService(db *sql.DB, encryption *EncryptionService) *TwoFactorService <span class="cov0" title="0">{
        return &amp;TwoFactorService{
                DB:         db,
                Encryption: encryption,
        }
}</span>

// NewTwoFactorServiceWithInterface creates a new 2FA service with interface
// Use this for testing with mock implementations
func NewTwoFactorServiceWithInterface(db interface {
        QueryRow(query string, args ...interface{}) *sql.Row
        Exec(query string, args ...interface{}) (sql.Result, error)
}, encryption EncryptionProvider) *TwoFactorService <span class="cov0" title="0">{
        return &amp;TwoFactorService{
                DB:         db,
                Encryption: encryption,
        }
}</span>

// Setup generates a new 2FA secret, QR code, and backup codes
func (s *TwoFactorService) Setup(userID int, email string) (*SetupResponse, error) <span class="cov0" title="0">{
        // Generate TOTP secret
        secret, err := totp.Generate(totp.GenerateOpts{
                Issuer:      "Monera Digital",
                AccountName: email,
                Period:      30,
                Digits:      6,
                Algorithm:   otp.AlgorithmSHA1,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate secret: %w", err)
        }</span>

        // Generate 10 backup codes
        <span class="cov0" title="0">backupCodes := make([]string, 10)
        for i := range backupCodes </span><span class="cov0" title="0">{
                code := make([]byte, 4)
                rand.Read(code)
                backupCodes[i] = hex.EncodeToString(code)
        }</span>

        // Encrypt and store secret and backup codes
        <span class="cov0" title="0">encryptedSecret, err := s.Encryption.Encrypt(secret.Secret())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to encrypt secret: %w", err)
        }</span>
        <span class="cov0" title="0">encryptedBackupCodes, err := json.Marshal(backupCodes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal backup codes: %w", err)
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE users
                SET two_factor_secret = $1, two_factor_backup_codes = $2
                WHERE id = $3`

        _, err = s.DB.Exec(query, encryptedSecret, string(encryptedBackupCodes), userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to store 2FA secret: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;SetupResponse{
                Secret:      secret.Secret(),
                QRCode:      secret.URL(),
                BackupCodes: backupCodes,
                OTPAuth:     secret.URL(),
        }, nil</span>
}

// Enable verifies TOTP token and enables 2FA for the user
func (s *TwoFactorService) Enable(userID int, token string) error <span class="cov0" title="0">{
        secret, err := s.getSecret(userID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("2FA not set up: %w", err)
        }</span>

        <span class="cov0" title="0">valid := totp.Validate(token, secret)
        if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid verification code")
        }</span>

        <span class="cov0" title="0">query := `UPDATE users SET two_factor_enabled = true WHERE id = $1`
        _, err = s.DB.Exec(query, userID)
        return err</span>
}

// Disable verifies token or backup code and disables 2FA
func (s *TwoFactorService) Disable(userID int, token string) error <span class="cov0" title="0">{
        valid, err := s.Verify(userID, token)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid verification code")
        }</span>

        <span class="cov0" title="0">query := `
                UPDATE users
                SET two_factor_enabled = false, two_factor_secret = NULL, two_factor_backup_codes = NULL
                WHERE id = $1`
        _, err = s.DB.Exec(query, userID)
        return err</span>
}

// Verify checks if a token is valid (TOTP or backup code)
func (s *TwoFactorService) Verify(userID int, token string) (bool, error) <span class="cov0" title="0">{
        secret, err := s.getSecret(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        // Check TOTP first
        <span class="cov0" title="0">if totp.Validate(token, secret) </span><span class="cov0" title="0">{
                return true, nil
        }</span>

        // Check backup codes
        <span class="cov0" title="0">backupCodes, err := s.getBackupCodes(userID)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">for i, code := range backupCodes </span><span class="cov0" title="0">{
                if code == token </span><span class="cov0" title="0">{
                        // Remove used backup code
                        remaining := append(backupCodes[:i], backupCodes[i+1:]...)
                        encryptedBackupCodes, err := json.Marshal(remaining)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf("failed to marshal backup codes: %w", err)
                        }</span>

                        <span class="cov0" title="0">query := `UPDATE users SET two_factor_backup_codes = $1 WHERE id = $2`
                        _, err = s.DB.Exec(query, string(encryptedBackupCodes), userID)
                        if err != nil </span><span class="cov0" title="0">{
                                return false, fmt.Errorf("failed to update backup codes: %w", err)
                        }</span>
                        <span class="cov0" title="0">return true, nil</span>
                }
        }

        <span class="cov0" title="0">return false, nil</span>
}

// IsEnabled checks if 2FA is enabled for a user
func (s *TwoFactorService) IsEnabled(userID int) (bool, error) <span class="cov0" title="0">{
        var enabled bool
        query := `SELECT two_factor_enabled FROM users WHERE id = $1`
        err := s.DB.QueryRow(query, userID).Scan(&amp;enabled)
        return enabled, err
}</span>

// getSecret retrieves and decrypts the 2FA secret for a user
func (s *TwoFactorService) getSecret(userID int) (string, error) <span class="cov0" title="0">{
        var encryptedSecret sql.NullString
        query := `SELECT two_factor_secret FROM users WHERE id = $1`
        err := s.DB.QueryRow(query, userID).Scan(&amp;encryptedSecret)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return "", fmt.Errorf("2FA not set up")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">if !encryptedSecret.Valid || encryptedSecret.String == "" </span><span class="cov0" title="0">{
                return "", fmt.Errorf("2FA not set up")
        }</span>
        <span class="cov0" title="0">secret, err := s.Encryption.Decrypt(encryptedSecret.String)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to decrypt secret: %w", err)
        }</span>
        <span class="cov0" title="0">return secret, nil</span>
}

// getBackupCodes retrieves and decrypts backup codes for a user
func (s *TwoFactorService) getBackupCodes(userID int) ([]string, error) <span class="cov0" title="0">{
        var encryptedCodes sql.NullString
        query := `SELECT two_factor_backup_codes FROM users WHERE id = $1`
        err := s.DB.QueryRow(query, userID).Scan(&amp;encryptedCodes)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("2FA not set up")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !encryptedCodes.Valid || encryptedCodes.String == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("2FA not set up")
        }</span>

        <span class="cov0" title="0">var codes []string
        if err := json.Unmarshal([]byte(encryptedCodes.String), &amp;codes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return codes, nil</span>
}

// VerifyAndLogin verifies 2FA token and returns login response data
func (s *TwoFactorService) VerifyAndLogin(userID int, token string) (*LoginResponse, error) <span class="cov0" title="0">{
        // 验证2FA令牌
        valid, err := s.Verify(userID, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("2FA verification failed: %w", err)
        }</span>
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid 2FA token")
        }</span>

        // 获取用户信息用于生成JWT
        <span class="cov0" title="0">var email string
        var twoFactorEnabled bool
        query := `SELECT email, two_factor_enabled FROM users WHERE id = $1`
        err = s.DB.QueryRow(query, userID).Scan(&amp;email, &amp;twoFactorEnabled)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get user: %w", err)
        }</span>

        // 这里只返回验证成功的用户信息，JWT生成在AuthService中处理
        <span class="cov0" title="0">return &amp;LoginResponse{
                User: &amp;models.User{
                        ID:    userID,
                        Email: email,
                },
        }, nil</span>
}

// generateTOTPToken generates a valid TOTP token for testing
// This is unexported and for testing purposes only
func generateTOTPToken(secret string) (string, error) <span class="cov0" title="0">{
        return totp.GenerateCode(secret, time.Now())
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package services

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "monera-digital/internal/coreapi"
        "monera-digital/internal/currency"
        "monera-digital/internal/dto"
        "monera-digital/internal/logger"
        "monera-digital/internal/models"
        "monera-digital/internal/repository"
        "time"

        "github.com/google/uuid"
)

type WalletService struct {
        repo          repository.Wallet
        coreAPIClient coreapi.CoreAPIClientInterface
}

func NewWalletService(repo repository.Wallet, coreAPIClient coreapi.CoreAPIClientInterface) *WalletService <span class="cov8" title="1">{
        return &amp;WalletService{repo: repo, coreAPIClient: coreAPIClient}
}</span>

// CreateWallet creates a new wallet for the user with productCode and currency.
func (s *WalletService) CreateWallet(ctx context.Context, userID int, productCode, currency string) (*models.WalletCreationRequest, error) <span class="cov8" title="1">{
        // Check for existing wallet with same product and currency
        existing, err := s.repo.GetWalletByUserProductCurrency(ctx, userID, productCode, currency)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existing != nil &amp;&amp; existing.Status == models.WalletCreationStatusSuccess </span><span class="cov8" title="1">{
                return existing, nil
        }</span>

        <span class="cov8" title="1">reqID := uuid.New().String()
        newReq := &amp;models.WalletCreationRequest{
                RequestID:   reqID,
                UserID:      userID,
                ProductCode: productCode,
                Currency:    currency,
                Status:      models.WalletCreationStatusCreating,
        }
        err = s.repo.CreateRequest(ctx, newReq)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create wallet request", "error", err.Error(), "userId", userID, "productCode", productCode, "currency", currency)
                return nil, err
        }</span>
        <span class="cov8" title="1">logger.Info("Wallet request created", "requestId", reqID, "userId", userID)

        if s.coreAPIClient == nil </span><span class="cov0" title="0">{
                errMsg := "Core API client not initialized"
                logger.Error(errMsg, "userId", userID)
                return nil, errors.New(errMsg)
        }</span>

        <span class="cov8" title="1">coreResp, err := s.coreAPIClient.CreateWallet(ctx, coreapi.CreateWalletRequest{
                UserID:      userID,
                ProductCode: productCode,
                Currency:    currency,
        })
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Core API wallet creation failed", "error", err.Error(), "userId", userID, "productCode", productCode, "currency", currency)
                s.repo.UpdateRequest(ctx, &amp;models.WalletCreationRequest{RequestID: reqID, Status: models.WalletCreationStatusFailed})
                return nil, fmt.Errorf("wallet creation failed: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("Core API wallet created successfully", "walletId", coreResp.WalletID, "userId", userID)

        newReq.Status = models.WalletCreationStatusSuccess
        newReq.WalletID = sql.NullString{String: coreResp.WalletID, Valid: true}
        newReq.Address = sql.NullString{String: coreResp.Address, Valid: true}
        if coreResp.Addresses != nil </span><span class="cov8" title="1">{
                addressesJSON, _ := json.Marshal(coreResp.Addresses)
                newReq.Addresses = sql.NullString{String: string(addressesJSON), Valid: true}
        }</span>
        <span class="cov8" title="1">newReq.UpdatedAt = time.Now()

        if err := s.repo.UpdateRequest(ctx, newReq); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to update wallet request", "error", err.Error(), "requestId", reqID)
        }</span>

        // Sync to user_wallets table - store individual wallet addresses
        <span class="cov8" title="1">userWallet := &amp;models.UserWallet{
                UserID:    userID,
                WalletID:  coreResp.WalletID,
                Currency:  currency,
                Address:   coreResp.Address,
                Status:    models.UserWalletStatusNormal,
                IsPrimary: true,
        }
        if reqID != "" </span><span class="cov8" title="1">{
                userWallet.RequestID = sql.NullString{String: reqID, Valid: true}
        }</span>
        <span class="cov8" title="1">if err := s.repo.CreateUserWallet(ctx, userWallet); err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to sync user wallet", "error", err.Error(), "userId", userID, "currency", currency)
                // Don't fail the operation if user_wallet sync fails
        }</span>

        <span class="cov8" title="1">return newReq, nil</span>
}

// buildCurrencyKey builds a valid currency key from token and network.
// Normalizes network aliases (TRON -&gt; TRC20) to standard names.
func buildCurrencyKey(token, network string) string <span class="cov8" title="1">{
        // Normalize network aliases
        network = currency.NormalizeNetwork(network)

        // Build the currency key
        currencyKey := currency.BuildCurrency(token, network)

        // Validate the currency is supported
        if !currency.IsValid(currencyKey) </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return currencyKey</span>
}

func (s *WalletService) GetWalletInfo(ctx context.Context, userID int) (*models.WalletCreationRequest, error) <span class="cov0" title="0">{
        // First try to find active/success wallet
        w, err := s.repo.GetActiveWalletByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // If not found, check if there is any request (e.g. creating)
        <span class="cov0" title="0">if w == nil </span><span class="cov0" title="0">{
                req, err := s.repo.GetRequestByUserID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if req != nil </span><span class="cov0" title="0">{
                        return req, nil
                }</span>
                <span class="cov0" title="0">return nil, nil</span>
        }

        // Merge addresses from user_wallets into wallet_creation_requests
        <span class="cov0" title="0">userWallets, err := s.repo.GetUserWalletsByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(userWallets) &gt; 0 </span><span class="cov0" title="0">{
                // Parse existing addresses
                addresses := make(map[string]string)
                if w.Addresses.Valid &amp;&amp; w.Addresses.String != "" </span><span class="cov0" title="0">{
                        if err := json.Unmarshal([]byte(w.Addresses.String), &amp;addresses); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("Failed to parse existing addresses", "error", err.Error())
                        }</span>
                }

                // Merge user_wallets addresses
                <span class="cov0" title="0">for _, uw := range userWallets </span><span class="cov0" title="0">{
                        if uw.Address != "" </span><span class="cov0" title="0">{
                                addresses[uw.Currency] = uw.Address
                        }</span>
                }

                // Update addresses JSON
                <span class="cov0" title="0">addressesJSON, _ := json.Marshal(addresses)
                w.Addresses = sql.NullString{String: string(addressesJSON), Valid: true}</span>
        }

        <span class="cov0" title="0">return w, nil</span>
}

type AddAddressRequest struct {
        Chain string
        Token string
}

// AddAddress adds a new wallet address for the given chain and token.
// It gets the address from Core API and stores it in user_wallets table.
func (s *WalletService) AddAddress(ctx context.Context, userID int, req AddAddressRequest) (*models.UserWallet, error) <span class="cov8" title="1">{
        // Get user's wallet info to get wallet_id and productCode
        wallet, err := s.repo.GetActiveWalletByUserID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fall back to user_wallets if no wallet_creation_requests
        <span class="cov8" title="1">if wallet == nil </span><span class="cov8" title="1">{
                userWallet, err := s.repo.GetActiveUserWallet(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if userWallet != nil </span><span class="cov8" title="1">{
                        wallet = convertUserWalletToRequest(userWallet)
                }</span>
        }

        <span class="cov8" title="1">if wallet == nil </span><span class="cov8" title="1">{
                return nil, errors.New("wallet not found")
        }</span>

        // Calculate currency key for the address
        <span class="cov8" title="1">addressKey := buildCurrencyKey(req.Token, req.Chain)
        if addressKey == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid currency: %s_%s", req.Token, req.Chain)
        }</span>

        // Check if address already exists in user_wallets
        <span class="cov8" title="1">existingWallet, err := s.repo.GetUserWalletByUserAndCurrency(ctx, userID, addressKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existingWallet != nil </span><span class="cov8" title="1">{
                logger.Info("Address already exists", "userId", userID, "currency", addressKey)
                return existingWallet, nil
        }</span>

        // Get address from Core API (REQUIRED, no fallback)
        <span class="cov8" title="1">if s.coreAPIClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Core API client not initialized")
        }</span>

        // Use wallet's ProductCode or default to X_FINANCE
        <span class="cov8" title="1">productCode := wallet.ProductCode
        if productCode == "" </span><span class="cov8" title="1">{
                productCode = "X_FINANCE"
        }</span>

        <span class="cov8" title="1">coreResp, err := s.coreAPIClient.GetAddress(ctx, coreapi.GetAddressRequest{
                UserID:      userID,
                ProductCode: productCode,
                Currency:    addressKey,
        })
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to get address from Core API: %w", err)
        }</span>

        <span class="cov8" title="1">logger.Info("Core API address fetched successfully", "userId", userID, "currency", addressKey)

        // Create new UserWallet record
        newWallet := &amp;models.UserWallet{
                UserID:    userID,
                WalletID:  wallet.WalletID.String,
                Currency:  addressKey,
                Address:   coreResp.Address,
                Status:    models.UserWalletStatusNormal,
                IsPrimary: false,
        }

        // Set optional fields if available
        if coreResp.AddressType != nil </span><span class="cov0" title="0">{
                newWallet.AddressType = sql.NullString{String: *coreResp.AddressType, Valid: true}
        }</span>
        <span class="cov8" title="1">if coreResp.DerivePath != nil </span><span class="cov0" title="0">{
                newWallet.DerivePath = sql.NullString{String: *coreResp.DerivePath, Valid: true}
        }</span>
        <span class="cov8" title="1">if wallet.RequestID != "" </span><span class="cov8" title="1">{
                newWallet.RequestID = sql.NullString{String: wallet.RequestID, Valid: true}
        }</span>

        // Store in user_wallets table
        <span class="cov8" title="1">result, err := s.repo.AddUserWalletAddress(ctx, newWallet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// GetAddressIncomeHistory 获取地址链上收款记录
func (s *WalletService) GetAddressIncomeHistory(ctx context.Context, userID int, address string) ([]coreapi.AddressIncomeRecord, error) <span class="cov0" title="0">{
        if s.coreAPIClient == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Core API client not initialized")
        }</span>

        <span class="cov0" title="0">return s.coreAPIClient.GetIncomeHistory(ctx, coreapi.GetIncomeHistoryRequest{
                Address: address,
        })</span>
}

// GetWalletAddress 获取钱包地址
// 优先从 Core API 获取，如果失败则从本地数据库获取
func (s *WalletService) GetWalletAddress(ctx context.Context, userID int, req dto.GetWalletAddressRequest) (*dto.WalletAddress, error) <span class="cov0" title="0">{
        // 优先从 Core API 获取
        if s.coreAPIClient != nil </span><span class="cov0" title="0">{
                addressInfo, err := s.coreAPIClient.GetAddress(ctx, coreapi.GetAddressRequest{
                        UserID:      userID,
                        ProductCode: req.ProductCode,
                        Currency:    req.Currency,
                })
                if err == nil </span><span class="cov0" title="0">{
                        return &amp;dto.WalletAddress{
                                Address:     addressInfo.Address,
                                AddressType: addressInfo.AddressType,
                                DerivePath:  addressInfo.DerivePath,
                        }, nil
                }</span>
                // 如果 Core API 返回错误，继续尝试从本地数据库获取
                <span class="cov0" title="0">logger.Info("Core API GetAddress failed, falling back to local database", "error", err.Error())</span>
        }

        // 从本地数据库获取钱包信息作为降级方案
        <span class="cov0" title="0">wallet, err := s.GetWalletInfo(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get wallet address: %v", err)
        }</span>
        <span class="cov0" title="0">if wallet == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet not found")
        }</span>

        // 解析 addresses JSON 并获取对应 currency 的地址
        <span class="cov0" title="0">var address string
        if wallet.Addresses.Valid &amp;&amp; wallet.Addresses.String != "" </span><span class="cov0" title="0">{
                addresses := make(map[string]string)
                if err := json.Unmarshal([]byte(wallet.Addresses.String), &amp;addresses); err != nil </span><span class="cov0" title="0">{
                        logger.Info("Failed to parse addresses JSON", "error", err.Error())
                }</span> else<span class="cov0" title="0"> {
                        // 优先查找对应 currency 的地址
                        address = addresses[req.Currency]
                        // 如果找不到，尝试查找任一地址
                        if address == "" </span><span class="cov0" title="0">{
                                for _, v := range addresses </span><span class="cov0" title="0">{
                                        address = v
                                        break</span>
                                }
                        }
                }
        }

        // 如果没有找到地址，尝试使用单一的 address 字段
        <span class="cov0" title="0">if address == "" &amp;&amp; wallet.Address.Valid &amp;&amp; wallet.Address.String != "" </span><span class="cov0" title="0">{
                address = wallet.Address.String
        }</span>

        <span class="cov0" title="0">if address == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wallet address not found")
        }</span>

        <span class="cov0" title="0">return &amp;dto.WalletAddress{
                Address: address,
        }, nil</span>
}

// Ensure dto types are not optimized away by linker
// This prevents "undefined type" errors in some build environments
var _ = dto.GetWalletAddressRequest{}
var _ = dto.WalletAddress{}

// convertUserWalletToRequest converts a UserWallet to WalletCreationRequest format
// for use in AddAddress flow. This enables looking up wallets from user_wallets
// table when wallet_creation_requests doesn't have a matching record.
func convertUserWalletToRequest(uw *models.UserWallet) *models.WalletCreationRequest <span class="cov8" title="1">{
        addressesJSON, _ := json.Marshal(map[string]string{uw.Currency: uw.Address})
        return &amp;models.WalletCreationRequest{
                UserID:      uw.UserID,
                ProductCode: "X_FINANCE",
                Currency:    uw.Currency,
                Status:      models.WalletCreationStatusSuccess,
                WalletID:    sql.NullString{String: uw.WalletID, Valid: uw.WalletID != ""},
                Address:     sql.NullString{String: uw.Address, Valid: uw.Address != ""},
                Addresses:   sql.NullString{String: string(addressesJSON), Valid: true},
        }
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package services

import (
        "context"
        "errors"
        "fmt"
        "strconv"
        "sync"
        "time"

        "monera-digital/internal/binance"
        "monera-digital/internal/repository"
)

var (
        ErrInsufficientBalance   = errors.New("insufficient balance")
        ErrProductNotFound       = errors.New("product not found")
        ErrOrderNotFound         = errors.New("order not found")
        ErrProductNotAvailable   = errors.New("product not available")
        ErrAmountBelowMin        = errors.New("amount below minimum")
        ErrAmountAboveMax        = errors.New("amount above maximum")
        ErrQuotaExceeded         = errors.New("quota exceeded")
        ErrOrderAlreadyRedeemed  = errors.New("order already redeemed")
        ErrInvalidRedemptionType = errors.New("invalid redemption type")
        ErrPriceFetchFailed      = errors.New("failed to fetch price")
        ErrJournalCreateFailed   = errors.New("failed to create journal record")
        ErrDuplicateRequest      = errors.New("duplicate request, please try again later")
)

type WealthService struct {
        repo        repository.Wealth
        accountRepo repository.AccountV2
        journalRepo repository.Journal
        lockMap     map[string]bool
        mu          map[string]*sync.Mutex
}

func NewWealthService(wealthRepo repository.Wealth, accountRepo repository.AccountV2, journalRepo repository.Journal) *WealthService <span class="cov8" title="1">{
        return &amp;WealthService{
                repo:        wealthRepo,
                accountRepo: accountRepo,
                journalRepo: journalRepo,
                lockMap:     make(map[string]bool),
                mu:          make(map[string]*sync.Mutex),
        }
}</span>

// getLock returns a mutex for the given key
func (s *WealthService) getLock(key string) *sync.Mutex <span class="cov8" title="1">{
        if s.mu[key] == nil </span><span class="cov8" title="1">{
                s.mu[key] = &amp;sync.Mutex{}
        }</span>
        <span class="cov8" title="1">return s.mu[key]</span>
}

// generateIdempotencyKey generates a unique key for idempotency check
func (s *WealthService) generateIdempotencyKey(userID int, productID int64, amount string) string <span class="cov8" title="1">{
        return fmt.Sprintf("subscribe:%d:%d:%s", userID, productID, amount)
}</span>

// isDuplicateCheck checks if this is a duplicate request
func (s *WealthService) isDuplicateCheck(key string) bool <span class="cov8" title="1">{
        if s.lockMap[key] </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">s.lockMap[key] = true
        return false</span>
}

// clearLock clears the lock for a key
func (s *WealthService) clearLock(key string) <span class="cov8" title="1">{
        delete(s.lockMap, key)
}</span>

type Asset struct {
        Currency      string  `json:"currency"`
        Total         string  `json:"total"`
        Available     string  `json:"available"`
        FrozenBalance string  `json:"frozenBalance"`
        UsdValue      float64 `json:"usdValue"`
}

func (s *WealthService) GetAssets(ctx context.Context, userID int) ([]*Asset, error) <span class="cov8" title="1">{
        accounts, err := s.accountRepo.GetAccountsByUserID(ctx, int64(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var currencies []string
        for _, a := range accounts </span><span class="cov8" title="1">{
                if a.Currency != "USDT" &amp;&amp; a.Currency != "USDC" &amp;&amp; a.Currency != "DAI" </span><span class="cov0" title="0">{
                        currencies = append(currencies, a.Currency)
                }</span>
        }
        <span class="cov8" title="1">prices := binance.NewPriceService().GetPricesFromCache(currencies)

        var result []*Asset
        for _, a := range accounts </span><span class="cov8" title="1">{
                available := subtractStrings(a.Balance, a.FrozenBalance)
                availableFloat, _ := strconv.ParseFloat(available, 64)
                usdValue := availableFloat

                if a.Currency == "USDT" || a.Currency == "USDC" || a.Currency == "DAI" </span><span class="cov8" title="1">{
                        usdValue = availableFloat
                }</span> else<span class="cov0" title="0"> if price, ok := prices[a.Currency]; ok </span><span class="cov0" title="0">{
                        usdValue = availableFloat * price
                }</span>

                <span class="cov8" title="1">result = append(result, &amp;Asset{
                        Currency:      a.Currency,
                        Total:         a.Balance,
                        Available:     available,
                        FrozenBalance: a.FrozenBalance,
                        UsdValue:      usdValue,
                })</span>
        }
        <span class="cov8" title="1">return result, nil</span>
}

func subtractStrings(a, b string) string <span class="cov8" title="1">{
        aFloat, errA := strconv.ParseFloat(a, 64)
        bFloat, errB := strconv.ParseFloat(b, 64)

        if errA != nil </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">if errB != nil </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov8" title="1">diff := aFloat - bFloat
        if diff &lt; 0 </span><span class="cov0" title="0">{
                diff = 0
        }</span>

        <span class="cov8" title="1">return strconv.FormatFloat(diff, 'f', -1, 64)</span>
}

type Product struct {
        ID               int64   `json:"id"`
        Title            string  `json:"title"`
        Currency         string  `json:"currency"`
        APY              float64 `json:"apy"`
        Duration         int     `json:"duration"`
        MinAmount        string  `json:"minAmount"`
        MaxAmount        string  `json:"maxAmount"`
        RemainingQuota   string  `json:"remainingQuota"`
        AutoRenewAllowed bool    `json:"autoRenewAllowed"`
}

type Order struct {
        ID               int64  `json:"id"`
        ProductTitle     string `json:"productTitle"`
        Currency         string `json:"currency"`
        Amount           string `json:"amount"`
        InterestExpected string `json:"interestExpected"`
        InterestPaid     string `json:"interestPaid"`
        InterestAccrued  string `json:"interestAccrued"`
        StartDate        string `json:"startDate"`
        EndDate          string `json:"endDate"`
        AutoRenew        bool   `json:"autoRenew"`
        Status           int    `json:"status"`
        RedemptionAmount string `json:"redemptionAmount,omitempty"`
        CreatedAt        string `json:"createdAt"`
}

func (s *WealthService) GetProducts(ctx context.Context, page, pageSize int) ([]*Product, int64, error) <span class="cov8" title="1">{
        products, err := s.repo.GetActiveProducts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">total := int64(len(products))

        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 10
        }</span>

        <span class="cov8" title="1">start := (page - 1) * pageSize
        end := start + pageSize
        if start &gt;= len(products) </span><span class="cov0" title="0">{
                return []*Product{}, total, nil
        }</span>
        <span class="cov8" title="1">if end &gt; len(products) </span><span class="cov8" title="1">{
                end = len(products)
        }</span>

        <span class="cov8" title="1">var result []*Product
        for _, p := range products[start:end] </span><span class="cov8" title="1">{
                apy, _ := strconv.ParseFloat(p.APY, 64)
                result = append(result, &amp;Product{
                        ID:               p.ID,
                        Title:            p.Title,
                        Currency:         p.Currency,
                        APY:              apy,
                        Duration:         p.Duration,
                        MinAmount:        p.MinAmount,
                        MaxAmount:        p.MaxAmount,
                        RemainingQuota:   p.TotalQuota,
                        AutoRenewAllowed: p.AutoRenewAllowed,
                })
        }</span>
        <span class="cov8" title="1">return result, total, nil</span>
}

func (s *WealthService) Subscribe(ctx context.Context, userID int, productID int64, amount string, autoRenew bool) (string, error) <span class="cov8" title="1">{
        idempotencyKey := s.generateIdempotencyKey(userID, productID, amount)
        mu := s.getLock(idempotencyKey)

        mu.Lock()
        defer func() </span><span class="cov8" title="1">{
                mu.Unlock()
                s.clearLock(idempotencyKey)
        }</span>()

        <span class="cov8" title="1">if s.isDuplicateCheck(idempotencyKey) </span><span class="cov0" title="0">{
                return "", ErrDuplicateRequest
        }</span>

        <span class="cov8" title="1">product, err := s.repo.GetProductByID(ctx, productID)
        if err != nil </span><span class="cov8" title="1">{
                return "", ErrProductNotFound
        }</span>

        <span class="cov8" title="1">if product.Status != 1 </span><span class="cov0" title="0">{
                return "", ErrProductNotFound
        }</span>

        <span class="cov8" title="1">available, _ := strconv.ParseFloat(amount, 64)
        if available &lt;= 0 </span><span class="cov0" title="0">{
                return "", ErrAmountBelowMin
        }</span>

        <span class="cov8" title="1">minAmount, _ := strconv.ParseFloat(product.MinAmount, 64)
        if available &lt; minAmount </span><span class="cov0" title="0">{
                return "", ErrAmountBelowMin
        }</span>

        <span class="cov8" title="1">maxAmount, _ := strconv.ParseFloat(product.MaxAmount, 64)
        if available &gt; maxAmount </span><span class="cov0" title="0">{
                return "", ErrAmountAboveMax
        }</span>

        <span class="cov8" title="1">soldQuota, _ := strconv.ParseFloat(product.SoldQuota, 64)
        totalQuota, _ := strconv.ParseFloat(product.TotalQuota, 64)
        if soldQuota+available &gt; totalQuota </span><span class="cov0" title="0">{
                return "", ErrQuotaExceeded
        }</span>

        <span class="cov8" title="1">account, err := s.accountRepo.GetAccountByUserIDAndCurrency(ctx, int64(userID), product.Currency)
        if err != nil </span><span class="cov0" title="0">{
                return "", ErrInsufficientBalance
        }</span>

        <span class="cov8" title="1">balance, _ := strconv.ParseFloat(account.Balance, 64)
        frozen, _ := strconv.ParseFloat(account.FrozenBalance, 64)
        availableBalance := balance - frozen
        if available &gt; availableBalance </span><span class="cov8" title="1">{
                return "", ErrInsufficientBalance
        }</span>

        <span class="cov0" title="0">err = s.accountRepo.FreezeBalance(ctx, account.ID, amount)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        startDate := now.Format("2006-01-02")
        endDate := now.AddDate(0, 0, product.Duration).Format("2006-01-02")

        apy, _ := strconv.ParseFloat(product.APY, 64)
        amountFloat, _ := strconv.ParseFloat(amount, 64)
        dailyInterest := amountFloat * (apy / 100) / 365
        interestExpected := strconv.FormatFloat(dailyInterest*float64(product.Duration), 'f', -1, 64)

        order := &amp;repository.WealthOrderModel{
                UserID:            int64(userID),
                ProductID:         productID,
                ProductTitle:      product.Title,
                Currency:          product.Currency,
                Amount:            amount,
                AutoRenew:         autoRenew,
                Status:            1,
                StartDate:         startDate,
                EndDate:           endDate,
                PrincipalRedeemed: "0",
                InterestExpected:  interestExpected,
                InterestPaid:      "0",
                InterestAccrued:   "0",
                LastInterestDate:  "",
                CreatedAt:         now.Format(time.RFC3339),
                UpdatedAt:         now.Format(time.RFC3339),
        }

        err = s.repo.CreateOrder(ctx, order)
        if err != nil </span><span class="cov0" title="0">{
                s.accountRepo.UnfreezeBalance(ctx, account.ID, amount)
                return "", err
        }</span>

        <span class="cov0" title="0">err = s.repo.UpdateProductSoldQuota(ctx, productID, amount)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[WARNING] Failed to update product sold quota: %v\n", err)
        }</span>

        <span class="cov0" title="0">serialNo := fmt.Sprintf("SUBSCRIBE-%s-%d", now.Format("20060102150405"), order.ID)
        balanceAfterFreeze := balance - available
        journalRecord := &amp;repository.JournalModel{
                SerialNo:        serialNo,
                UserID:          int64(userID),
                AccountID:       account.ID,
                Amount:          "-" + amount,
                BalanceSnapshot: strconv.FormatFloat(balanceAfterFreeze, 'f', -1, 64),
                BizType:         "SUBSCRIBE_FREEZE",
                RefID:           &amp;order.ID,
                CreatedAt:       now.Format(time.RFC3339),
        }

        err = s.journalRepo.CreateJournalRecord(ctx, journalRecord)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("[ERROR] Failed to create journal record: %v\n", err)
                return "", ErrJournalCreateFailed
        }</span>

        <span class="cov0" title="0">return interestExpected, nil</span>
}

func (s *WealthService) GetOrders(ctx context.Context, userID int, page, pageSize int) ([]*Order, int64, error) <span class="cov8" title="1">{
        orders, err := s.repo.GetOrdersByUserID(ctx, int64(userID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">total := int64(len(orders))

        if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt; 1 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>

        <span class="cov8" title="1">start := (page - 1) * pageSize
        end := start + pageSize
        if start &gt;= len(orders) </span><span class="cov0" title="0">{
                return []*Order{}, total, nil
        }</span>
        <span class="cov8" title="1">if end &gt; len(orders) </span><span class="cov8" title="1">{
                end = len(orders)
        }</span>

        <span class="cov8" title="1">var result []*Order
        for _, o := range orders[start:end] </span><span class="cov8" title="1">{
                result = append(result, &amp;Order{
                        ID:               o.ID,
                        ProductTitle:     o.ProductTitle,
                        Currency:         o.Currency,
                        Amount:           o.Amount,
                        InterestExpected: o.InterestExpected,
                        InterestPaid:     o.InterestPaid,
                        InterestAccrued:  o.InterestAccrued,
                        StartDate:        o.StartDate,
                        EndDate:          o.EndDate,
                        AutoRenew:        o.AutoRenew,
                        Status:           o.Status,
                        CreatedAt:        o.CreatedAt,
                })
        }</span>
        <span class="cov8" title="1">return result, total, nil</span>
}

func (s *WealthService) Redeem(ctx context.Context, userID int, orderID int64, redemptionType string) error <span class="cov8" title="1">{
        fmt.Printf("[DEBUG] Redeem - userID: %d, orderID: %d, redemptionType: %s\n", userID, orderID, redemptionType)
        order, err := s.repo.GetOrderByID(ctx, orderID)
        if err != nil </span><span class="cov8" title="1">{
                fmt.Printf("[DEBUG] Redeem - GetOrderByID error: %v\n", err)
                return ErrOrderNotFound
        }</span>
        <span class="cov8" title="1">fmt.Printf("[DEBUG] Redeem - order found: ID=%d, UserID=%d, Status=%d, Amount=%s\n", order.ID, order.UserID, order.Status, order.Amount)

        if order.UserID != int64(userID) </span><span class="cov0" title="0">{
                return ErrOrderNotFound
        }</span>

        <span class="cov8" title="1">if order.Status == 3 </span><span class="cov8" title="1">{
                return ErrOrderAlreadyRedeemed
        }</span>

        <span class="cov8" title="1">now := time.Now()
        endDate, _ := time.Parse("2006-01-02", order.EndDate)
        isExpired := now.After(endDate) || now.Equal(endDate)

        if !isExpired </span><span class="cov8" title="1">{
                fmt.Printf("[DEBUG] Early redemption for order %d - only unfreezing principal\n", order.ID)
        }</span>

        <span class="cov8" title="1">isFull := redemptionType == "full"
        if isFull </span><span class="cov8" title="1">{
                account, err := s.accountRepo.GetAccountByUserIDAndCurrency(ctx, int64(userID), order.Currency)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">err = s.accountRepo.UnfreezeBalance(ctx, account.ID, order.Amount)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">order.Status = 3
                order.RedemptionAmount = order.Amount
                order.RedeemedAt = now.Format(time.RFC3339)

                if isExpired </span><span class="cov8" title="1">{
                        interestAccrued, _ := strconv.ParseFloat(order.InterestAccrued, 64)
                        if interestAccrued &gt; 0 </span><span class="cov8" title="1">{
                                err = s.accountRepo.AddBalance(ctx, account.ID, order.InterestAccrued)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov8" title="1">balance, _ := strconv.ParseFloat(account.Balance, 64)
                                newBalance := balance + interestAccrued

                                journalRecord := &amp;repository.JournalModel{
                                        SerialNo:        fmt.Sprintf("REDEEM-PRINCIPAL-%s-%d", now.Format("20060102150405"), order.ID),
                                        UserID:          int64(userID),
                                        AccountID:       account.ID,
                                        Amount:          order.Amount,
                                        BalanceSnapshot: strconv.FormatFloat(newBalance, 'f', -1, 64),
                                        BizType:         "REDEEM_UNFREEZE",
                                        RefID:           &amp;order.ID,
                                        CreatedAt:       now.Format(time.RFC3339),
                                }
                                err = s.journalRepo.CreateJournalRecord(ctx, journalRecord)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("[ERROR] Failed to create principal journal record: %v\n", err)
                                }</span>

                                <span class="cov8" title="1">interestJournalRecord := &amp;repository.JournalModel{
                                        SerialNo:        fmt.Sprintf("REDEEM-INTEREST-%s-%d", now.Format("20060102150405"), order.ID),
                                        UserID:          int64(userID),
                                        AccountID:       account.ID,
                                        Amount:          order.InterestAccrued,
                                        BalanceSnapshot: strconv.FormatFloat(newBalance+interestAccrued, 'f', -1, 64),
                                        BizType:         "INTEREST_PAYOUT",
                                        RefID:           &amp;order.ID,
                                        CreatedAt:       now.Format(time.RFC3339),
                                }
                                err = s.journalRepo.CreateJournalRecord(ctx, interestJournalRecord)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("[ERROR] Failed to create interest journal record: %v\n", err)
                                }</span>

                                <span class="cov8" title="1">order.InterestPaid = order.InterestAccrued
                                order.InterestAccrued = "0"
                                fmt.Printf("[DEBUG] Paid interest %.8f %s for order %d\n", interestAccrued, order.Currency, order.ID)</span>
                        } else<span class="cov0" title="0"> {
                                balance, _ := strconv.ParseFloat(account.Balance, 64)
                                newBalance := balance + interestAccrued
                                journalRecord := &amp;repository.JournalModel{
                                        SerialNo:        fmt.Sprintf("REDEEM-PRINCIPAL-%s-%d", now.Format("20060102150405"), order.ID),
                                        UserID:          int64(userID),
                                        AccountID:       account.ID,
                                        Amount:          order.Amount,
                                        BalanceSnapshot: strconv.FormatFloat(newBalance, 'f', -1, 64),
                                        BizType:         "REDEEM_UNFREEZE",
                                        RefID:           &amp;order.ID,
                                        CreatedAt:       now.Format(time.RFC3339),
                                }
                                err = s.journalRepo.CreateJournalRecord(ctx, journalRecord)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("[ERROR] Failed to create principal journal record: %v\n", err)
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        balance, _ := strconv.ParseFloat(account.Balance, 64)
                        principalAmt, _ := strconv.ParseFloat(order.Amount, 64)
                        newBalance := balance + principalAmt
                        journalRecord := &amp;repository.JournalModel{
                                SerialNo:        fmt.Sprintf("REDEEM-PRINCIPAL-%s-%d", now.Format("20060102150405"), order.ID),
                                UserID:          int64(userID),
                                AccountID:       account.ID,
                                Amount:          order.Amount,
                                BalanceSnapshot: strconv.FormatFloat(newBalance, 'f', -1, 64),
                                BizType:         "REDEEM_UNFREEZE",
                                RefID:           &amp;order.ID,
                                CreatedAt:       now.Format(time.RFC3339),
                        }
                        err = s.journalRepo.CreateJournalRecord(ctx, journalRecord)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("[ERROR] Failed to create principal journal record: %v\n", err)
                        }</span>
                }
        }

        <span class="cov8" title="1">return s.repo.UpdateOrder(ctx, order)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "fmt"
        "strconv"
        "time"

        "github.com/google/uuid"
        "monera-digital/internal/models"
        "monera-digital/internal/repository"
)

type ISafeheronService interface {
        Withdraw(ctx context.Context, req SafeheronWithdrawalRequest) (*SafeheronWithdrawalResponse, error)
}

type WithdrawalService struct {
        repo      *repository.Repository
        safeheron ISafeheronService
        db        *sql.DB
}

func NewWithdrawalService(db *sql.DB, repo *repository.Repository, safeheron ISafeheronService) *WithdrawalService <span class="cov8" title="1">{
        return &amp;WithdrawalService{
                db:        db,
                repo:      repo,
                safeheron: safeheron,
        }
}</span>

// CreateWithdrawal handles the withdrawal process with transaction support
func (s *WithdrawalService) CreateWithdrawal(ctx context.Context, userID int, req models.CreateWithdrawalRequest) (*models.WithdrawalOrder, error) <span class="cov8" title="1">{
        // Validate and get resources
        amount, address, err := s.validateWithdrawalRequest(ctx, userID, req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Call Safeheron first (external API, not in transaction)
        <span class="cov8" title="1">requestID := uuid.New().String()
        shResp, err := s.safeheron.Withdraw(ctx, SafeheronWithdrawalRequest{
                CoinType:  req.Asset,
                ChainType: address.ChainType,
                ToAddress: address.WalletAddress,
                Amount:    req.Amount,
                RequestID: requestID,
        })

        if err != nil </span><span class="cov0" title="0">{
                // Fail: Unfreeze (outside transaction)
                if unfreezeErr := s.repo.Account.ReleaseFrozenBalance(ctx, userID, amount); unfreezeErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("safeheron failed and failed to unfreeze balance: %w (unfreeze error: %v)", err, unfreezeErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("safeheron failed: %w", err)</span>
        }

        // Success: Execute DB operations in transaction
        <span class="cov8" title="1">var createdOrder *models.WithdrawalOrder
        txErr := s.withdrawWithTransaction(ctx, userID, amount, address, req, shResp, &amp;createdOrder)
        if txErr != nil </span><span class="cov0" title="0">{
                return nil, txErr
        }</span>

        <span class="cov8" title="1">return createdOrder, nil</span>
}

// withdrawWithTransaction handles the DB operations in a transaction
func (s *WithdrawalService) withdrawWithTransaction(ctx context.Context, userID int, amount float64, address *models.WithdrawalAddress, req models.CreateWithdrawalRequest, shResp *SafeheronWithdrawalResponse, orderPtr **models.WithdrawalOrder) error <span class="cov8" title="1">{
        tx, err := s.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                }</span>
        }()

        // Execute all DB operations using the transaction

        // 1. Freeze Balance
        <span class="cov8" title="1">_, err = tx.ExecContext(ctx,
                `UPDATE account SET frozen_balance = frozen_balance + $1, version = version + 1, updated_at = $3 WHERE user_id = $2`,
                amount, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to freeze balance: %w", err)
        }</span>

        // 2. Deduct Balance
        <span class="cov8" title="1">result, err := tx.ExecContext(ctx,
                `UPDATE account SET frozen_balance = frozen_balance - $1, balance = balance - $1, version = version + 1, updated_at = $3 WHERE user_id = $2 AND frozen_balance &gt;= $1`,
                amount, userID, time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deduct balance: %w", err)
        }</span>
        <span class="cov8" title="1">rows, _ := result.RowsAffected()
        if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to deduct balance: account not found or insufficient frozen balance")
        }</span>

        // 3. Create Order
        <span class="cov8" title="1">order := &amp;models.WithdrawalOrder{
                UserID:           userID,
                Amount:           req.Amount,
                NetworkFee:       shResp.NetworkFee,
                PlatformFee:      "0",
                ActualAmount:     req.Amount,
                ChainType:        address.ChainType,
                CoinType:         req.Asset,
                ToAddress:        address.WalletAddress,
                SafeheronOrderID: sql.NullString{String: shResp.SafeheronOrderID, Valid: true},
                TransactionHash:  sql.NullString{String: shResp.TxHash, Valid: true},
                Status:           "SENT",
        }

        err = tx.QueryRowContext(ctx,
                `INSERT INTO withdrawal_order (
                        user_id, amount, network_fee, platform_fee, actual_amount,
                        chain_type, coin_type, to_address, safeheron_order_id, transaction_hash,
                        status, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                RETURNING id, created_at`,
                order.UserID, order.Amount, order.NetworkFee, order.PlatformFee, order.ActualAmount,
                order.ChainType, order.CoinType, order.ToAddress, order.SafeheronOrderID, order.TransactionHash,
                order.Status, time.Now(), time.Now(),
        ).Scan(&amp;order.ID, &amp;order.CreatedAt)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create order: %w", err)
        }</span>

        // Commit transaction
        <span class="cov8" title="1">if err = tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov8" title="1">*orderPtr = order
        return nil</span>
}

// validateWithdrawalRequest validates the withdrawal request and returns required resources
func (s *WithdrawalService) validateWithdrawalRequest(ctx context.Context, userID int, req models.CreateWithdrawalRequest) (float64, *models.WithdrawalAddress, error) <span class="cov8" title="1">{
        // Validate amount
        amount, err := strconv.ParseFloat(req.Amount, 64)
        if err != nil || amount &lt;= 0 </span><span class="cov0" title="0">{
                return 0, nil, errors.New("invalid amount")
        }</span>

        // Get Account
        <span class="cov8" title="1">account, err := s.repo.Account.GetByUserIDAndType(ctx, userID, "WEALTH")
        if err != nil </span><span class="cov0" title="0">{
                if err == repository.ErrNotFound </span><span class="cov0" title="0">{
                        return 0, nil, errors.New("account not found")
                }</span>
                <span class="cov0" title="0">return 0, nil, err</span>
        }

        // Check balance
        <span class="cov8" title="1">available := account.Balance - account.FrozenBalance
        if available &lt; amount </span><span class="cov8" title="1">{
                return 0, nil, errors.New("insufficient balance")
        }</span>

        // Get Address
        <span class="cov8" title="1">address, err := s.repo.Address.GetAddressByID(ctx, req.AddressID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, nil, errors.New("address not found")
        }</span>
        <span class="cov8" title="1">if address.UserID != userID </span><span class="cov0" title="0">{
                return 0, nil, errors.New("address does not belong to user")
        }</span>

        <span class="cov8" title="1">return amount, address, nil</span>
}

// GetWithdrawalHistory returns the withdrawal history for a user
func (s *WithdrawalService) GetWithdrawalHistory(ctx context.Context, userID int) ([]*models.WithdrawalOrder, error) <span class="cov0" title="0">{
        return s.repo.Withdrawal.GetOrdersByUserID(ctx, userID)
}</span>

func (s *WithdrawalService) GetWithdrawalByID(ctx context.Context, userID int, id int) (*models.WithdrawalOrder, error) <span class="cov0" title="0">{
        order, err := s.repo.Withdrawal.GetOrderByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if order.UserID != userID </span><span class="cov0" title="0">{
                return nil, errors.New("unauthorized")
        }</span>
        <span class="cov0" title="0">return order, nil</span>
}

func (s *WithdrawalService) EstimateFee(ctx context.Context, asset, chain, amount string) (string, string, error) <span class="cov0" title="0">{
        // Stub implementation
        // Real implementation would call Safeheron or Blockchain node
        // Fee = Network Fee + Platform Fee
        // For now, return static or simple calc

        networkFee := "1.0"
        if asset == "ETH" </span><span class="cov0" title="0">{
                networkFee = "0.002"
        }</span>

        // platformFee := "0" // 0.5% maybe?
        <span class="cov0" title="0">amt, _ := strconv.ParseFloat(amount, 64)
        if amt &gt; 0 </span>{<span class="cov0" title="0">
                // platformFee = fmt.Sprintf("%.4f", amt*0.005)
        }</span>

        // Received = Amount - Network - Platform
        <span class="cov0" title="0">received := amt - 1.0 // Simple sub
        if received &lt; 0 </span><span class="cov0" title="0">{
                received = 0
        }</span>

        <span class="cov0" title="0">return networkFee, fmt.Sprintf("%.4f", received), nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package utils

import (
        "golang.org/x/crypto/bcrypt"
)

// HashPassword hashes a password using bcrypt
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        return string(bytes), err
}</span>

// CheckPasswordHash compares a password with a hash
func CheckPasswordHash(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package utils

import (
        "errors"
        "time"

        "monera-digital/internal/models"

        "github.com/golang-jwt/jwt/v5"
)

func GenerateJWT(userID int, email string, secret string) (string, error) <span class="cov0" title="0">{
        now := time.Now()
        claims := models.TokenClaims{
                UserID:    userID,
                Email:     email,
                TokenType: "access",
                ExpiresAt: now.Add(time.Hour * 24).Unix(),
                IssuedAt:  now.Unix(),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, &amp;claims)
        return token.SignedString([]byte(secret))
}</span>

// ParseJWT parses and validates a JWT token, returning the claims
func ParseJWT(tokenString, secret string) (map[string]interface{}, error) <span class="cov0" title="0">{
        token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("unexpected signing method")
                }</span>
                <span class="cov0" title="0">return []byte(secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return map[string]interface{}(claims), nil
        }</span>

        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// internal/validator/validator.go
package validator

import (
        "fmt"
        "regexp"
)

// Validator interface for validation operations
type Validator interface {
        ValidateEmail(email string) error
        ValidatePassword(password string) error
        ValidateAmount(amount float64) error
        ValidateAddress(address string) error
        ValidateAsset(asset string) error
        ValidateDuration(days int) error
}

// DefaultValidator implements Validator interface
type DefaultValidator struct{}

// NewValidator creates a new validator instance
func NewValidator() Validator <span class="cov0" title="0">{
        return &amp;DefaultValidator{}
}</span>

// ValidationError represents a validation error
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("validation error on field '%s': %s", e.Field, e.Message)
}</span>

// ValidateEmail validates email format
func (v *DefaultValidator) ValidateEmail(email string) error <span class="cov0" title="0">{
        if email == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "email", Message: "email is required"}
        }</span>

        // RFC 5322 simplified email regex
        <span class="cov0" title="0">emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
        if !emailRegex.MatchString(email) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "email", Message: "invalid email format"}
        }</span>

        <span class="cov0" title="0">if len(email) &gt; 255 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "email", Message: "email is too long (max 255 characters)"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidatePassword validates password strength
func (v *DefaultValidator) ValidatePassword(password string) error <span class="cov0" title="0">{
        if password == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "password", Message: "password is required"}
        }</span>

        <span class="cov0" title="0">if len(password) &lt; 8 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "password", Message: "password must be at least 8 characters"}
        }</span>

        <span class="cov0" title="0">if len(password) &gt; 128 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "password", Message: "password is too long (max 128 characters)"}
        }</span>

        // Check for at least one uppercase letter
        <span class="cov0" title="0">hasUpper := regexp.MustCompile(`[A-Z]`).MatchString(password)
        // Check for at least one lowercase letter
        hasLower := regexp.MustCompile(`[a-z]`).MatchString(password)
        // Check for at least one digit
        hasDigit := regexp.MustCompile(`[0-9]`).MatchString(password)

        if !hasUpper || !hasLower || !hasDigit </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "password",
                        Message: "password must contain uppercase, lowercase, and digit characters",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateAmount validates numeric amount
func (v *DefaultValidator) ValidateAmount(amount float64) error <span class="cov0" title="0">{
        if amount &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "amount", Message: "amount must be greater than 0"}
        }</span>

        <span class="cov0" title="0">if amount &gt; 1e15 </span><span class="cov0" title="0">{ // Prevent overflow
                return &amp;ValidationError{Field: "amount", Message: "amount is too large"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateAddress validates blockchain address format
func (v *DefaultValidator) ValidateAddress(address string) error <span class="cov0" title="0">{
        if address == "" </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "address", Message: "address is required"}
        }</span>

        <span class="cov0" title="0">if len(address) &lt; 20 || len(address) &gt; 100 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "address", Message: "address length must be between 20 and 100 characters"}
        }</span>

        // Basic alphanumeric check (supports most blockchain addresses)
        <span class="cov0" title="0">addressRegex := regexp.MustCompile(`^[a-zA-Z0-9]+$`)
        if !addressRegex.MatchString(address) </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "address", Message: "address contains invalid characters"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateAsset validates asset type
func (v *DefaultValidator) ValidateAsset(asset string) error <span class="cov0" title="0">{
        validAssets := map[string]bool{
                "BTC":  true,
                "ETH":  true,
                "USDC": true,
                "USDT": true,
        }

        if !validAssets[asset] </span><span class="cov0" title="0">{
                return &amp;ValidationError{
                        Field:   "asset",
                        Message: "asset must be one of: BTC, ETH, USDC, USDT",
                }
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateDuration validates lending duration
func (v *DefaultValidator) ValidateDuration(days int) error <span class="cov0" title="0">{
        if days &lt;= 0 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "duration_days", Message: "duration must be greater than 0"}
        }</span>

        <span class="cov0" title="0">if days &gt; 365 </span><span class="cov0" title="0">{
                return &amp;ValidationError{Field: "duration_days", Message: "duration must not exceed 365 days"}
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
